============================= test session starts ==============================
platform linux -- Python 3.11.11, pytest-8.3.4, pluggy-1.5.0
rootdir: /data/swe-fl/TMP/testbed/matplotlib__matplotlib-24149
configfile: pytest.ini
plugins: xdist-3.6.1, cov-6.0.0, rerunfailures-15.0, timeout-2.3.1
collected 832 items

lib/matplotlib/tests/test_axes.py ...FFFFFFFFF.......................... [  4%]
............................F.F......F.F...............................F [ 13%]
............................................F........................... [ 21%]
..F.F.......F.........F..........FFF..............FFFF.................. [ 30%]
........................................................................ [ 39%]
........................................................................ [ 47%]
........................................................................ [ 56%]
..........................................F....................F.....FFF [ 65%]
FF.FFF.F................................................................ [ 73%]
........................................................................ [ 82%]
...............................................F........................ [ 91%]
........................................................................ [ 99%]
.F                                                                       [100%]

=================================== FAILURES ===================================
_________________________ test_label_loc_vertical[png] _________________________

ext = 'png'
request = <FixtureRequest for <Function test_label_loc_vertical[png]>>
args = (), kwargs = {}, file_name = 'test_label_loc_vertical[png]'
fig_test = <Figure size 640x480 with 2 Axes>
fig_ref = <Figure size 640x480 with 0 Axes>, figs = []

    @pytest.mark.parametrize("ext", extensions)
    def wrapper(*args, ext, request, **kwargs):
        if 'ext' in old_sig.parameters:
            kwargs['ext'] = ext
        if 'request' in old_sig.parameters:
            kwargs['request'] = request
    
        file_name = "".join(c for c in request.node.name
                            if c in ALLOWED_CHARS)
        try:
            fig_test = plt.figure("test")
            fig_ref = plt.figure("reference")
            with _collect_new_figures() as figs:
>               func(*args, fig_test=fig_test, fig_ref=fig_ref, **kwargs)

lib/matplotlib/testing/decorators.py:472: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/matplotlib/tests/test_axes.py:80: in test_label_loc_vertical
    cbar = fig_test.colorbar(sc)
lib/matplotlib/figure.py:1278: in colorbar
    cb = cbar.Colorbar(cax, mappable, **cb_kw)
lib/matplotlib/_api/deprecation.py:384: in wrapper
    return func(*inner_args, **inner_kwargs)
lib/matplotlib/colorbar.py:396: in __init__
    self._draw_all()
lib/matplotlib/colorbar.py:523: in _draw_all
    self._short_axis().set_ticks([])
lib/matplotlib/axis.py:2033: in set_ticks
    result = self._set_tick_locations(ticks, minor=minor)
lib/matplotlib/axis.py:1977: in _set_tick_locations
    ticks = self.convert_units(ticks)
lib/matplotlib/axis.py:1663: in convert_units
    self.converter = munits.registry.get_converter(x)
lib/matplotlib/units.py:200: in get_converter
    first = cbook._safe_first_finite(x)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = []

    def _safe_first_finite(obj, *, skip_nonfinite=True):
        """
        Return the first non-None (and optionally finite) element in *obj*.
    
        This is a method for internal use.
    
        This is an type-independent way of obtaining the first non-None element,
        supporting both index access and the iterator protocol.
        The first non-None element will be obtained when skip_none is True.
        """
        def safe_isfinite(val):
            if val is None:
                return False
            try:
                return np.isfinite(val) if np.isscalar(val) else True
            except TypeError:
                # This is something that numpy can not make heads or tails
                # of, assume "finite"
                return True
        if skip_nonfinite is False:
            if isinstance(obj, collections.abc.Iterator):
                # needed to accept `array.flat` as input.
                # np.flatiter reports as an instance of collections.Iterator
                # but can still be indexed via [].
                # This has the side effect of re-setting the iterator, but
                # that is acceptable.
                try:
                    return obj[0]
                except TypeError:
                    pass
                raise RuntimeError("matplotlib does not support generators "
                                   "as input")
            return next(iter(obj))
        elif isinstance(obj, np.flatiter):
            # TODO do the finite filtering on this
            return obj[0]
        elif isinstance(obj, collections.abc.Iterator):
            raise RuntimeError("matplotlib does not "
                               "support generators as input")
        else:
            for val in obj:
                if safe_isfinite(val):
                    return val
>           raise ValueError('No finite values found in the input.')
E           ValueError: No finite values found in the input.

lib/matplotlib/cbook/__init__.py:1752: ValueError
_________________________ test_label_loc_vertical[pdf] _________________________

ext = 'pdf'
request = <FixtureRequest for <Function test_label_loc_vertical[pdf]>>
args = (), kwargs = {}, file_name = 'test_label_loc_vertical[pdf]'
fig_test = <Figure size 640x480 with 2 Axes>
fig_ref = <Figure size 640x480 with 0 Axes>, figs = []

    @pytest.mark.parametrize("ext", extensions)
    def wrapper(*args, ext, request, **kwargs):
        if 'ext' in old_sig.parameters:
            kwargs['ext'] = ext
        if 'request' in old_sig.parameters:
            kwargs['request'] = request
    
        file_name = "".join(c for c in request.node.name
                            if c in ALLOWED_CHARS)
        try:
            fig_test = plt.figure("test")
            fig_ref = plt.figure("reference")
            with _collect_new_figures() as figs:
>               func(*args, fig_test=fig_test, fig_ref=fig_ref, **kwargs)

lib/matplotlib/testing/decorators.py:472: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/matplotlib/tests/test_axes.py:80: in test_label_loc_vertical
    cbar = fig_test.colorbar(sc)
lib/matplotlib/figure.py:1278: in colorbar
    cb = cbar.Colorbar(cax, mappable, **cb_kw)
lib/matplotlib/_api/deprecation.py:384: in wrapper
    return func(*inner_args, **inner_kwargs)
lib/matplotlib/colorbar.py:396: in __init__
    self._draw_all()
lib/matplotlib/colorbar.py:523: in _draw_all
    self._short_axis().set_ticks([])
lib/matplotlib/axis.py:2033: in set_ticks
    result = self._set_tick_locations(ticks, minor=minor)
lib/matplotlib/axis.py:1977: in _set_tick_locations
    ticks = self.convert_units(ticks)
lib/matplotlib/axis.py:1663: in convert_units
    self.converter = munits.registry.get_converter(x)
lib/matplotlib/units.py:200: in get_converter
    first = cbook._safe_first_finite(x)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = []

    def _safe_first_finite(obj, *, skip_nonfinite=True):
        """
        Return the first non-None (and optionally finite) element in *obj*.
    
        This is a method for internal use.
    
        This is an type-independent way of obtaining the first non-None element,
        supporting both index access and the iterator protocol.
        The first non-None element will be obtained when skip_none is True.
        """
        def safe_isfinite(val):
            if val is None:
                return False
            try:
                return np.isfinite(val) if np.isscalar(val) else True
            except TypeError:
                # This is something that numpy can not make heads or tails
                # of, assume "finite"
                return True
        if skip_nonfinite is False:
            if isinstance(obj, collections.abc.Iterator):
                # needed to accept `array.flat` as input.
                # np.flatiter reports as an instance of collections.Iterator
                # but can still be indexed via [].
                # This has the side effect of re-setting the iterator, but
                # that is acceptable.
                try:
                    return obj[0]
                except TypeError:
                    pass
                raise RuntimeError("matplotlib does not support generators "
                                   "as input")
            return next(iter(obj))
        elif isinstance(obj, np.flatiter):
            # TODO do the finite filtering on this
            return obj[0]
        elif isinstance(obj, collections.abc.Iterator):
            raise RuntimeError("matplotlib does not "
                               "support generators as input")
        else:
            for val in obj:
                if safe_isfinite(val):
                    return val
>           raise ValueError('No finite values found in the input.')
E           ValueError: No finite values found in the input.

lib/matplotlib/cbook/__init__.py:1752: ValueError
_________________________ test_label_loc_vertical[svg] _________________________

ext = 'svg'
request = <FixtureRequest for <Function test_label_loc_vertical[svg]>>
args = (), kwargs = {}, file_name = 'test_label_loc_vertical[svg]'
fig_test = <Figure size 640x480 with 2 Axes>
fig_ref = <Figure size 640x480 with 0 Axes>, figs = []

    @pytest.mark.parametrize("ext", extensions)
    def wrapper(*args, ext, request, **kwargs):
        if 'ext' in old_sig.parameters:
            kwargs['ext'] = ext
        if 'request' in old_sig.parameters:
            kwargs['request'] = request
    
        file_name = "".join(c for c in request.node.name
                            if c in ALLOWED_CHARS)
        try:
            fig_test = plt.figure("test")
            fig_ref = plt.figure("reference")
            with _collect_new_figures() as figs:
>               func(*args, fig_test=fig_test, fig_ref=fig_ref, **kwargs)

lib/matplotlib/testing/decorators.py:472: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/matplotlib/tests/test_axes.py:80: in test_label_loc_vertical
    cbar = fig_test.colorbar(sc)
lib/matplotlib/figure.py:1278: in colorbar
    cb = cbar.Colorbar(cax, mappable, **cb_kw)
lib/matplotlib/_api/deprecation.py:384: in wrapper
    return func(*inner_args, **inner_kwargs)
lib/matplotlib/colorbar.py:396: in __init__
    self._draw_all()
lib/matplotlib/colorbar.py:523: in _draw_all
    self._short_axis().set_ticks([])
lib/matplotlib/axis.py:2033: in set_ticks
    result = self._set_tick_locations(ticks, minor=minor)
lib/matplotlib/axis.py:1977: in _set_tick_locations
    ticks = self.convert_units(ticks)
lib/matplotlib/axis.py:1663: in convert_units
    self.converter = munits.registry.get_converter(x)
lib/matplotlib/units.py:200: in get_converter
    first = cbook._safe_first_finite(x)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = []

    def _safe_first_finite(obj, *, skip_nonfinite=True):
        """
        Return the first non-None (and optionally finite) element in *obj*.
    
        This is a method for internal use.
    
        This is an type-independent way of obtaining the first non-None element,
        supporting both index access and the iterator protocol.
        The first non-None element will be obtained when skip_none is True.
        """
        def safe_isfinite(val):
            if val is None:
                return False
            try:
                return np.isfinite(val) if np.isscalar(val) else True
            except TypeError:
                # This is something that numpy can not make heads or tails
                # of, assume "finite"
                return True
        if skip_nonfinite is False:
            if isinstance(obj, collections.abc.Iterator):
                # needed to accept `array.flat` as input.
                # np.flatiter reports as an instance of collections.Iterator
                # but can still be indexed via [].
                # This has the side effect of re-setting the iterator, but
                # that is acceptable.
                try:
                    return obj[0]
                except TypeError:
                    pass
                raise RuntimeError("matplotlib does not support generators "
                                   "as input")
            return next(iter(obj))
        elif isinstance(obj, np.flatiter):
            # TODO do the finite filtering on this
            return obj[0]
        elif isinstance(obj, collections.abc.Iterator):
            raise RuntimeError("matplotlib does not "
                               "support generators as input")
        else:
            for val in obj:
                if safe_isfinite(val):
                    return val
>           raise ValueError('No finite values found in the input.')
E           ValueError: No finite values found in the input.

lib/matplotlib/cbook/__init__.py:1752: ValueError
________________________ test_label_loc_horizontal[png] ________________________

ext = 'png'
request = <FixtureRequest for <Function test_label_loc_horizontal[png]>>
args = (), kwargs = {}, file_name = 'test_label_loc_horizontal[png]'
fig_test = <Figure size 640x480 with 2 Axes>
fig_ref = <Figure size 640x480 with 0 Axes>, figs = []

    @pytest.mark.parametrize("ext", extensions)
    def wrapper(*args, ext, request, **kwargs):
        if 'ext' in old_sig.parameters:
            kwargs['ext'] = ext
        if 'request' in old_sig.parameters:
            kwargs['request'] = request
    
        file_name = "".join(c for c in request.node.name
                            if c in ALLOWED_CHARS)
        try:
            fig_test = plt.figure("test")
            fig_ref = plt.figure("reference")
            with _collect_new_figures() as figs:
>               func(*args, fig_test=fig_test, fig_ref=fig_ref, **kwargs)

lib/matplotlib/testing/decorators.py:472: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/matplotlib/tests/test_axes.py:99: in test_label_loc_horizontal
    cbar = fig_test.colorbar(sc, orientation='horizontal')
lib/matplotlib/figure.py:1278: in colorbar
    cb = cbar.Colorbar(cax, mappable, **cb_kw)
lib/matplotlib/_api/deprecation.py:384: in wrapper
    return func(*inner_args, **inner_kwargs)
lib/matplotlib/colorbar.py:396: in __init__
    self._draw_all()
lib/matplotlib/colorbar.py:523: in _draw_all
    self._short_axis().set_ticks([])
lib/matplotlib/axis.py:2033: in set_ticks
    result = self._set_tick_locations(ticks, minor=minor)
lib/matplotlib/axis.py:1977: in _set_tick_locations
    ticks = self.convert_units(ticks)
lib/matplotlib/axis.py:1663: in convert_units
    self.converter = munits.registry.get_converter(x)
lib/matplotlib/units.py:200: in get_converter
    first = cbook._safe_first_finite(x)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = []

    def _safe_first_finite(obj, *, skip_nonfinite=True):
        """
        Return the first non-None (and optionally finite) element in *obj*.
    
        This is a method for internal use.
    
        This is an type-independent way of obtaining the first non-None element,
        supporting both index access and the iterator protocol.
        The first non-None element will be obtained when skip_none is True.
        """
        def safe_isfinite(val):
            if val is None:
                return False
            try:
                return np.isfinite(val) if np.isscalar(val) else True
            except TypeError:
                # This is something that numpy can not make heads or tails
                # of, assume "finite"
                return True
        if skip_nonfinite is False:
            if isinstance(obj, collections.abc.Iterator):
                # needed to accept `array.flat` as input.
                # np.flatiter reports as an instance of collections.Iterator
                # but can still be indexed via [].
                # This has the side effect of re-setting the iterator, but
                # that is acceptable.
                try:
                    return obj[0]
                except TypeError:
                    pass
                raise RuntimeError("matplotlib does not support generators "
                                   "as input")
            return next(iter(obj))
        elif isinstance(obj, np.flatiter):
            # TODO do the finite filtering on this
            return obj[0]
        elif isinstance(obj, collections.abc.Iterator):
            raise RuntimeError("matplotlib does not "
                               "support generators as input")
        else:
            for val in obj:
                if safe_isfinite(val):
                    return val
>           raise ValueError('No finite values found in the input.')
E           ValueError: No finite values found in the input.

lib/matplotlib/cbook/__init__.py:1752: ValueError
________________________ test_label_loc_horizontal[pdf] ________________________

ext = 'pdf'
request = <FixtureRequest for <Function test_label_loc_horizontal[pdf]>>
args = (), kwargs = {}, file_name = 'test_label_loc_horizontal[pdf]'
fig_test = <Figure size 640x480 with 2 Axes>
fig_ref = <Figure size 640x480 with 0 Axes>, figs = []

    @pytest.mark.parametrize("ext", extensions)
    def wrapper(*args, ext, request, **kwargs):
        if 'ext' in old_sig.parameters:
            kwargs['ext'] = ext
        if 'request' in old_sig.parameters:
            kwargs['request'] = request
    
        file_name = "".join(c for c in request.node.name
                            if c in ALLOWED_CHARS)
        try:
            fig_test = plt.figure("test")
            fig_ref = plt.figure("reference")
            with _collect_new_figures() as figs:
>               func(*args, fig_test=fig_test, fig_ref=fig_ref, **kwargs)

lib/matplotlib/testing/decorators.py:472: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/matplotlib/tests/test_axes.py:99: in test_label_loc_horizontal
    cbar = fig_test.colorbar(sc, orientation='horizontal')
lib/matplotlib/figure.py:1278: in colorbar
    cb = cbar.Colorbar(cax, mappable, **cb_kw)
lib/matplotlib/_api/deprecation.py:384: in wrapper
    return func(*inner_args, **inner_kwargs)
lib/matplotlib/colorbar.py:396: in __init__
    self._draw_all()
lib/matplotlib/colorbar.py:523: in _draw_all
    self._short_axis().set_ticks([])
lib/matplotlib/axis.py:2033: in set_ticks
    result = self._set_tick_locations(ticks, minor=minor)
lib/matplotlib/axis.py:1977: in _set_tick_locations
    ticks = self.convert_units(ticks)
lib/matplotlib/axis.py:1663: in convert_units
    self.converter = munits.registry.get_converter(x)
lib/matplotlib/units.py:200: in get_converter
    first = cbook._safe_first_finite(x)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = []

    def _safe_first_finite(obj, *, skip_nonfinite=True):
        """
        Return the first non-None (and optionally finite) element in *obj*.
    
        This is a method for internal use.
    
        This is an type-independent way of obtaining the first non-None element,
        supporting both index access and the iterator protocol.
        The first non-None element will be obtained when skip_none is True.
        """
        def safe_isfinite(val):
            if val is None:
                return False
            try:
                return np.isfinite(val) if np.isscalar(val) else True
            except TypeError:
                # This is something that numpy can not make heads or tails
                # of, assume "finite"
                return True
        if skip_nonfinite is False:
            if isinstance(obj, collections.abc.Iterator):
                # needed to accept `array.flat` as input.
                # np.flatiter reports as an instance of collections.Iterator
                # but can still be indexed via [].
                # This has the side effect of re-setting the iterator, but
                # that is acceptable.
                try:
                    return obj[0]
                except TypeError:
                    pass
                raise RuntimeError("matplotlib does not support generators "
                                   "as input")
            return next(iter(obj))
        elif isinstance(obj, np.flatiter):
            # TODO do the finite filtering on this
            return obj[0]
        elif isinstance(obj, collections.abc.Iterator):
            raise RuntimeError("matplotlib does not "
                               "support generators as input")
        else:
            for val in obj:
                if safe_isfinite(val):
                    return val
>           raise ValueError('No finite values found in the input.')
E           ValueError: No finite values found in the input.

lib/matplotlib/cbook/__init__.py:1752: ValueError
________________________ test_label_loc_horizontal[svg] ________________________

ext = 'svg'
request = <FixtureRequest for <Function test_label_loc_horizontal[svg]>>
args = (), kwargs = {}, file_name = 'test_label_loc_horizontal[svg]'
fig_test = <Figure size 640x480 with 2 Axes>
fig_ref = <Figure size 640x480 with 0 Axes>, figs = []

    @pytest.mark.parametrize("ext", extensions)
    def wrapper(*args, ext, request, **kwargs):
        if 'ext' in old_sig.parameters:
            kwargs['ext'] = ext
        if 'request' in old_sig.parameters:
            kwargs['request'] = request
    
        file_name = "".join(c for c in request.node.name
                            if c in ALLOWED_CHARS)
        try:
            fig_test = plt.figure("test")
            fig_ref = plt.figure("reference")
            with _collect_new_figures() as figs:
>               func(*args, fig_test=fig_test, fig_ref=fig_ref, **kwargs)

lib/matplotlib/testing/decorators.py:472: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/matplotlib/tests/test_axes.py:99: in test_label_loc_horizontal
    cbar = fig_test.colorbar(sc, orientation='horizontal')
lib/matplotlib/figure.py:1278: in colorbar
    cb = cbar.Colorbar(cax, mappable, **cb_kw)
lib/matplotlib/_api/deprecation.py:384: in wrapper
    return func(*inner_args, **inner_kwargs)
lib/matplotlib/colorbar.py:396: in __init__
    self._draw_all()
lib/matplotlib/colorbar.py:523: in _draw_all
    self._short_axis().set_ticks([])
lib/matplotlib/axis.py:2033: in set_ticks
    result = self._set_tick_locations(ticks, minor=minor)
lib/matplotlib/axis.py:1977: in _set_tick_locations
    ticks = self.convert_units(ticks)
lib/matplotlib/axis.py:1663: in convert_units
    self.converter = munits.registry.get_converter(x)
lib/matplotlib/units.py:200: in get_converter
    first = cbook._safe_first_finite(x)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = []

    def _safe_first_finite(obj, *, skip_nonfinite=True):
        """
        Return the first non-None (and optionally finite) element in *obj*.
    
        This is a method for internal use.
    
        This is an type-independent way of obtaining the first non-None element,
        supporting both index access and the iterator protocol.
        The first non-None element will be obtained when skip_none is True.
        """
        def safe_isfinite(val):
            if val is None:
                return False
            try:
                return np.isfinite(val) if np.isscalar(val) else True
            except TypeError:
                # This is something that numpy can not make heads or tails
                # of, assume "finite"
                return True
        if skip_nonfinite is False:
            if isinstance(obj, collections.abc.Iterator):
                # needed to accept `array.flat` as input.
                # np.flatiter reports as an instance of collections.Iterator
                # but can still be indexed via [].
                # This has the side effect of re-setting the iterator, but
                # that is acceptable.
                try:
                    return obj[0]
                except TypeError:
                    pass
                raise RuntimeError("matplotlib does not support generators "
                                   "as input")
            return next(iter(obj))
        elif isinstance(obj, np.flatiter):
            # TODO do the finite filtering on this
            return obj[0]
        elif isinstance(obj, collections.abc.Iterator):
            raise RuntimeError("matplotlib does not "
                               "support generators as input")
        else:
            for val in obj:
                if safe_isfinite(val):
                    return val
>           raise ValueError('No finite values found in the input.')
E           ValueError: No finite values found in the input.

lib/matplotlib/cbook/__init__.py:1752: ValueError
____________________________ test_label_loc_rc[png] ____________________________

ext = 'png', request = <FixtureRequest for <Function test_label_loc_rc[png]>>
args = (), kwargs = {}, file_name = 'test_label_loc_rc[png]'
fig_test = <Figure size 640x480 with 2 Axes>
fig_ref = <Figure size 640x480 with 0 Axes>, figs = []

    @pytest.mark.parametrize("ext", extensions)
    def wrapper(*args, ext, request, **kwargs):
        if 'ext' in old_sig.parameters:
            kwargs['ext'] = ext
        if 'request' in old_sig.parameters:
            kwargs['request'] = request
    
        file_name = "".join(c for c in request.node.name
                            if c in ALLOWED_CHARS)
        try:
            fig_test = plt.figure("test")
            fig_ref = plt.figure("reference")
            with _collect_new_figures() as figs:
>               func(*args, fig_test=fig_test, fig_ref=fig_ref, **kwargs)

lib/matplotlib/testing/decorators.py:472: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/matplotlib/tests/test_axes.py:120: in test_label_loc_rc
    cbar = fig_test.colorbar(sc, orientation='horizontal')
lib/matplotlib/figure.py:1278: in colorbar
    cb = cbar.Colorbar(cax, mappable, **cb_kw)
lib/matplotlib/_api/deprecation.py:384: in wrapper
    return func(*inner_args, **inner_kwargs)
lib/matplotlib/colorbar.py:396: in __init__
    self._draw_all()
lib/matplotlib/colorbar.py:523: in _draw_all
    self._short_axis().set_ticks([])
lib/matplotlib/axis.py:2033: in set_ticks
    result = self._set_tick_locations(ticks, minor=minor)
lib/matplotlib/axis.py:1977: in _set_tick_locations
    ticks = self.convert_units(ticks)
lib/matplotlib/axis.py:1663: in convert_units
    self.converter = munits.registry.get_converter(x)
lib/matplotlib/units.py:200: in get_converter
    first = cbook._safe_first_finite(x)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = []

    def _safe_first_finite(obj, *, skip_nonfinite=True):
        """
        Return the first non-None (and optionally finite) element in *obj*.
    
        This is a method for internal use.
    
        This is an type-independent way of obtaining the first non-None element,
        supporting both index access and the iterator protocol.
        The first non-None element will be obtained when skip_none is True.
        """
        def safe_isfinite(val):
            if val is None:
                return False
            try:
                return np.isfinite(val) if np.isscalar(val) else True
            except TypeError:
                # This is something that numpy can not make heads or tails
                # of, assume "finite"
                return True
        if skip_nonfinite is False:
            if isinstance(obj, collections.abc.Iterator):
                # needed to accept `array.flat` as input.
                # np.flatiter reports as an instance of collections.Iterator
                # but can still be indexed via [].
                # This has the side effect of re-setting the iterator, but
                # that is acceptable.
                try:
                    return obj[0]
                except TypeError:
                    pass
                raise RuntimeError("matplotlib does not support generators "
                                   "as input")
            return next(iter(obj))
        elif isinstance(obj, np.flatiter):
            # TODO do the finite filtering on this
            return obj[0]
        elif isinstance(obj, collections.abc.Iterator):
            raise RuntimeError("matplotlib does not "
                               "support generators as input")
        else:
            for val in obj:
                if safe_isfinite(val):
                    return val
>           raise ValueError('No finite values found in the input.')
E           ValueError: No finite values found in the input.

lib/matplotlib/cbook/__init__.py:1752: ValueError
____________________________ test_label_loc_rc[pdf] ____________________________

ext = 'pdf', request = <FixtureRequest for <Function test_label_loc_rc[pdf]>>
args = (), kwargs = {}, file_name = 'test_label_loc_rc[pdf]'
fig_test = <Figure size 640x480 with 2 Axes>
fig_ref = <Figure size 640x480 with 0 Axes>, figs = []

    @pytest.mark.parametrize("ext", extensions)
    def wrapper(*args, ext, request, **kwargs):
        if 'ext' in old_sig.parameters:
            kwargs['ext'] = ext
        if 'request' in old_sig.parameters:
            kwargs['request'] = request
    
        file_name = "".join(c for c in request.node.name
                            if c in ALLOWED_CHARS)
        try:
            fig_test = plt.figure("test")
            fig_ref = plt.figure("reference")
            with _collect_new_figures() as figs:
>               func(*args, fig_test=fig_test, fig_ref=fig_ref, **kwargs)

lib/matplotlib/testing/decorators.py:472: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/matplotlib/tests/test_axes.py:120: in test_label_loc_rc
    cbar = fig_test.colorbar(sc, orientation='horizontal')
lib/matplotlib/figure.py:1278: in colorbar
    cb = cbar.Colorbar(cax, mappable, **cb_kw)
lib/matplotlib/_api/deprecation.py:384: in wrapper
    return func(*inner_args, **inner_kwargs)
lib/matplotlib/colorbar.py:396: in __init__
    self._draw_all()
lib/matplotlib/colorbar.py:523: in _draw_all
    self._short_axis().set_ticks([])
lib/matplotlib/axis.py:2033: in set_ticks
    result = self._set_tick_locations(ticks, minor=minor)
lib/matplotlib/axis.py:1977: in _set_tick_locations
    ticks = self.convert_units(ticks)
lib/matplotlib/axis.py:1663: in convert_units
    self.converter = munits.registry.get_converter(x)
lib/matplotlib/units.py:200: in get_converter
    first = cbook._safe_first_finite(x)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = []

    def _safe_first_finite(obj, *, skip_nonfinite=True):
        """
        Return the first non-None (and optionally finite) element in *obj*.
    
        This is a method for internal use.
    
        This is an type-independent way of obtaining the first non-None element,
        supporting both index access and the iterator protocol.
        The first non-None element will be obtained when skip_none is True.
        """
        def safe_isfinite(val):
            if val is None:
                return False
            try:
                return np.isfinite(val) if np.isscalar(val) else True
            except TypeError:
                # This is something that numpy can not make heads or tails
                # of, assume "finite"
                return True
        if skip_nonfinite is False:
            if isinstance(obj, collections.abc.Iterator):
                # needed to accept `array.flat` as input.
                # np.flatiter reports as an instance of collections.Iterator
                # but can still be indexed via [].
                # This has the side effect of re-setting the iterator, but
                # that is acceptable.
                try:
                    return obj[0]
                except TypeError:
                    pass
                raise RuntimeError("matplotlib does not support generators "
                                   "as input")
            return next(iter(obj))
        elif isinstance(obj, np.flatiter):
            # TODO do the finite filtering on this
            return obj[0]
        elif isinstance(obj, collections.abc.Iterator):
            raise RuntimeError("matplotlib does not "
                               "support generators as input")
        else:
            for val in obj:
                if safe_isfinite(val):
                    return val
>           raise ValueError('No finite values found in the input.')
E           ValueError: No finite values found in the input.

lib/matplotlib/cbook/__init__.py:1752: ValueError
____________________________ test_label_loc_rc[svg] ____________________________

ext = 'svg', request = <FixtureRequest for <Function test_label_loc_rc[svg]>>
args = (), kwargs = {}, file_name = 'test_label_loc_rc[svg]'
fig_test = <Figure size 640x480 with 2 Axes>
fig_ref = <Figure size 640x480 with 0 Axes>, figs = []

    @pytest.mark.parametrize("ext", extensions)
    def wrapper(*args, ext, request, **kwargs):
        if 'ext' in old_sig.parameters:
            kwargs['ext'] = ext
        if 'request' in old_sig.parameters:
            kwargs['request'] = request
    
        file_name = "".join(c for c in request.node.name
                            if c in ALLOWED_CHARS)
        try:
            fig_test = plt.figure("test")
            fig_ref = plt.figure("reference")
            with _collect_new_figures() as figs:
>               func(*args, fig_test=fig_test, fig_ref=fig_ref, **kwargs)

lib/matplotlib/testing/decorators.py:472: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/matplotlib/tests/test_axes.py:120: in test_label_loc_rc
    cbar = fig_test.colorbar(sc, orientation='horizontal')
lib/matplotlib/figure.py:1278: in colorbar
    cb = cbar.Colorbar(cax, mappable, **cb_kw)
lib/matplotlib/_api/deprecation.py:384: in wrapper
    return func(*inner_args, **inner_kwargs)
lib/matplotlib/colorbar.py:396: in __init__
    self._draw_all()
lib/matplotlib/colorbar.py:523: in _draw_all
    self._short_axis().set_ticks([])
lib/matplotlib/axis.py:2033: in set_ticks
    result = self._set_tick_locations(ticks, minor=minor)
lib/matplotlib/axis.py:1977: in _set_tick_locations
    ticks = self.convert_units(ticks)
lib/matplotlib/axis.py:1663: in convert_units
    self.converter = munits.registry.get_converter(x)
lib/matplotlib/units.py:200: in get_converter
    first = cbook._safe_first_finite(x)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = []

    def _safe_first_finite(obj, *, skip_nonfinite=True):
        """
        Return the first non-None (and optionally finite) element in *obj*.
    
        This is a method for internal use.
    
        This is an type-independent way of obtaining the first non-None element,
        supporting both index access and the iterator protocol.
        The first non-None element will be obtained when skip_none is True.
        """
        def safe_isfinite(val):
            if val is None:
                return False
            try:
                return np.isfinite(val) if np.isscalar(val) else True
            except TypeError:
                # This is something that numpy can not make heads or tails
                # of, assume "finite"
                return True
        if skip_nonfinite is False:
            if isinstance(obj, collections.abc.Iterator):
                # needed to accept `array.flat` as input.
                # np.flatiter reports as an instance of collections.Iterator
                # but can still be indexed via [].
                # This has the side effect of re-setting the iterator, but
                # that is acceptable.
                try:
                    return obj[0]
                except TypeError:
                    pass
                raise RuntimeError("matplotlib does not support generators "
                                   "as input")
            return next(iter(obj))
        elif isinstance(obj, np.flatiter):
            # TODO do the finite filtering on this
            return obj[0]
        elif isinstance(obj, collections.abc.Iterator):
            raise RuntimeError("matplotlib does not "
                               "support generators as input")
        else:
            for val in obj:
                if safe_isfinite(val):
                    return val
>           raise ValueError('No finite values found in the input.')
E           ValueError: No finite values found in the input.

lib/matplotlib/cbook/__init__.py:1752: ValueError
____________________________ test_hexbin_empty[png] ____________________________

    @image_comparison(['hexbin_empty.png', 'hexbin_empty.png'], remove_text=True)
    def test_hexbin_empty():
        # From #3886: creating hexbin from empty dataset raises ValueError
        fig, ax = plt.subplots()
>       ax.hexbin([], [])

lib/matplotlib/tests/test_axes.py:903: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/matplotlib/__init__.py:1423: in inner
    return func(ax, *map(sanitize_sequence, args), **kwargs)
lib/matplotlib/axes/_axes.py:4811: in hexbin
    self._process_unit_info([("x", x), ("y", y)], kwargs, convert=False)
lib/matplotlib/axes/_base.py:2585: in _process_unit_info
    axis.update_units(data)
lib/matplotlib/axis.py:1605: in update_units
    converter = munits.registry.get_converter(data)
lib/matplotlib/units.py:200: in get_converter
    first = cbook._safe_first_finite(x)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = []

    def _safe_first_finite(obj, *, skip_nonfinite=True):
        """
        Return the first non-None (and optionally finite) element in *obj*.
    
        This is a method for internal use.
    
        This is an type-independent way of obtaining the first non-None element,
        supporting both index access and the iterator protocol.
        The first non-None element will be obtained when skip_none is True.
        """
        def safe_isfinite(val):
            if val is None:
                return False
            try:
                return np.isfinite(val) if np.isscalar(val) else True
            except TypeError:
                # This is something that numpy can not make heads or tails
                # of, assume "finite"
                return True
        if skip_nonfinite is False:
            if isinstance(obj, collections.abc.Iterator):
                # needed to accept `array.flat` as input.
                # np.flatiter reports as an instance of collections.Iterator
                # but can still be indexed via [].
                # This has the side effect of re-setting the iterator, but
                # that is acceptable.
                try:
                    return obj[0]
                except TypeError:
                    pass
                raise RuntimeError("matplotlib does not support generators "
                                   "as input")
            return next(iter(obj))
        elif isinstance(obj, np.flatiter):
            # TODO do the finite filtering on this
            return obj[0]
        elif isinstance(obj, collections.abc.Iterator):
            raise RuntimeError("matplotlib does not "
                               "support generators as input")
        else:
            for val in obj:
                if safe_isfinite(val):
                    return val
>           raise ValueError('No finite values found in the input.')
E           ValueError: No finite values found in the input.

lib/matplotlib/cbook/__init__.py:1752: ValueError
_____________________________ test_hexbin_log[png] _____________________________

    @image_comparison(['hexbin_log.png'], style='mpl20')
    def test_hexbin_log():
        # Issue #1636 (and also test log scaled colorbar)
    
        # Remove this line when this test image is regenerated.
        plt.rcParams['pcolormesh.snap'] = False
    
        np.random.seed(19680801)
        n = 100000
        x = np.random.standard_normal(n)
        y = 2.0 + 3.0 * x + 4.0 * np.random.standard_normal(n)
        y = np.power(2, y * 0.5)
    
        fig, ax = plt.subplots()
        h = ax.hexbin(x, y, yscale='log', bins='log',
                      marginals=True, reduce_C_function=np.sum)
>       plt.colorbar(h)

lib/matplotlib/tests/test_axes.py:936: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/matplotlib/pyplot.py:2055: in colorbar
    ret = gcf().colorbar(mappable, cax=cax, ax=ax, **kwargs)
lib/matplotlib/figure.py:1278: in colorbar
    cb = cbar.Colorbar(cax, mappable, **cb_kw)
lib/matplotlib/_api/deprecation.py:384: in wrapper
    return func(*inner_args, **inner_kwargs)
lib/matplotlib/colorbar.py:396: in __init__
    self._draw_all()
lib/matplotlib/colorbar.py:523: in _draw_all
    self._short_axis().set_ticks([])
lib/matplotlib/axis.py:2033: in set_ticks
    result = self._set_tick_locations(ticks, minor=minor)
lib/matplotlib/axis.py:1977: in _set_tick_locations
    ticks = self.convert_units(ticks)
lib/matplotlib/axis.py:1663: in convert_units
    self.converter = munits.registry.get_converter(x)
lib/matplotlib/units.py:200: in get_converter
    first = cbook._safe_first_finite(x)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = []

    def _safe_first_finite(obj, *, skip_nonfinite=True):
        """
        Return the first non-None (and optionally finite) element in *obj*.
    
        This is a method for internal use.
    
        This is an type-independent way of obtaining the first non-None element,
        supporting both index access and the iterator protocol.
        The first non-None element will be obtained when skip_none is True.
        """
        def safe_isfinite(val):
            if val is None:
                return False
            try:
                return np.isfinite(val) if np.isscalar(val) else True
            except TypeError:
                # This is something that numpy can not make heads or tails
                # of, assume "finite"
                return True
        if skip_nonfinite is False:
            if isinstance(obj, collections.abc.Iterator):
                # needed to accept `array.flat` as input.
                # np.flatiter reports as an instance of collections.Iterator
                # but can still be indexed via [].
                # This has the side effect of re-setting the iterator, but
                # that is acceptable.
                try:
                    return obj[0]
                except TypeError:
                    pass
                raise RuntimeError("matplotlib does not support generators "
                                   "as input")
            return next(iter(obj))
        elif isinstance(obj, np.flatiter):
            # TODO do the finite filtering on this
            return obj[0]
        elif isinstance(obj, collections.abc.Iterator):
            raise RuntimeError("matplotlib does not "
                               "support generators as input")
        else:
            for val in obj:
                if safe_isfinite(val):
                    return val
>           raise ValueError('No finite values found in the input.')
E           ValueError: No finite values found in the input.

lib/matplotlib/cbook/__init__.py:1752: ValueError
_____________________ test_limits_empty_data[png-scatter] ______________________

ext = 'png'
request = <FixtureRequest for <Function test_limits_empty_data[png-scatter]>>
args = (), kwargs = {'plot_fun': 'scatter'}
file_name = 'test_limits_empty_data[png-scatter]'
fig_test = <Figure size 640x480 with 1 Axes>
fig_ref = <Figure size 640x480 with 1 Axes>, figs = []

    @pytest.mark.parametrize("ext", extensions)
    def wrapper(*args, ext, request, **kwargs):
        if 'ext' in old_sig.parameters:
            kwargs['ext'] = ext
        if 'request' in old_sig.parameters:
            kwargs['request'] = request
    
        file_name = "".join(c for c in request.node.name
                            if c in ALLOWED_CHARS)
        try:
            fig_test = plt.figure("test")
            fig_ref = plt.figure("reference")
            with _collect_new_figures() as figs:
>               func(*args, fig_test=fig_test, fig_ref=fig_ref, **kwargs)

lib/matplotlib/testing/decorators.py:472: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/matplotlib/tests/test_axes.py:1007: in test_limits_empty_data
    getattr(ax_test, plot_fun)([], [])
lib/matplotlib/__init__.py:1423: in inner
    return func(ax, *map(sanitize_sequence, args), **kwargs)
lib/matplotlib/axes/_axes.py:4540: in scatter
    x, y = self._process_unit_info([("x", x), ("y", y)], kwargs)
lib/matplotlib/axes/_base.py:2585: in _process_unit_info
    axis.update_units(data)
lib/matplotlib/axis.py:1605: in update_units
    converter = munits.registry.get_converter(data)
lib/matplotlib/units.py:200: in get_converter
    first = cbook._safe_first_finite(x)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = []

    def _safe_first_finite(obj, *, skip_nonfinite=True):
        """
        Return the first non-None (and optionally finite) element in *obj*.
    
        This is a method for internal use.
    
        This is an type-independent way of obtaining the first non-None element,
        supporting both index access and the iterator protocol.
        The first non-None element will be obtained when skip_none is True.
        """
        def safe_isfinite(val):
            if val is None:
                return False
            try:
                return np.isfinite(val) if np.isscalar(val) else True
            except TypeError:
                # This is something that numpy can not make heads or tails
                # of, assume "finite"
                return True
        if skip_nonfinite is False:
            if isinstance(obj, collections.abc.Iterator):
                # needed to accept `array.flat` as input.
                # np.flatiter reports as an instance of collections.Iterator
                # but can still be indexed via [].
                # This has the side effect of re-setting the iterator, but
                # that is acceptable.
                try:
                    return obj[0]
                except TypeError:
                    pass
                raise RuntimeError("matplotlib does not support generators "
                                   "as input")
            return next(iter(obj))
        elif isinstance(obj, np.flatiter):
            # TODO do the finite filtering on this
            return obj[0]
        elif isinstance(obj, collections.abc.Iterator):
            raise RuntimeError("matplotlib does not "
                               "support generators as input")
        else:
            for val in obj:
                if safe_isfinite(val):
                    return val
>           raise ValueError('No finite values found in the input.')
E           ValueError: No finite values found in the input.

lib/matplotlib/cbook/__init__.py:1752: ValueError
___________________ test_limits_empty_data[png-fill_between] ___________________

ext = 'png'
request = <FixtureRequest for <Function test_limits_empty_data[png-fill_between]>>
args = (), kwargs = {'plot_fun': 'fill_between'}
file_name = 'test_limits_empty_data[png-fill_between]'
fig_test = <Figure size 640x480 with 1 Axes>
fig_ref = <Figure size 640x480 with 1 Axes>, figs = []

    @pytest.mark.parametrize("ext", extensions)
    def wrapper(*args, ext, request, **kwargs):
        if 'ext' in old_sig.parameters:
            kwargs['ext'] = ext
        if 'request' in old_sig.parameters:
            kwargs['request'] = request
    
        file_name = "".join(c for c in request.node.name
                            if c in ALLOWED_CHARS)
        try:
            fig_test = plt.figure("test")
            fig_ref = plt.figure("reference")
            with _collect_new_figures() as figs:
>               func(*args, fig_test=fig_test, fig_ref=fig_ref, **kwargs)

lib/matplotlib/testing/decorators.py:472: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/matplotlib/tests/test_axes.py:1007: in test_limits_empty_data
    getattr(ax_test, plot_fun)([], [])
lib/matplotlib/__init__.py:1423: in inner
    return func(ax, *map(sanitize_sequence, args), **kwargs)
lib/matplotlib/axes/_axes.py:5371: in fill_between
    return self._fill_between_x_or_y(
lib/matplotlib/axes/_axes.py:5277: in _fill_between_x_or_y
    ma.masked_invalid, self._process_unit_info(
lib/matplotlib/axes/_base.py:2585: in _process_unit_info
    axis.update_units(data)
lib/matplotlib/axis.py:1605: in update_units
    converter = munits.registry.get_converter(data)
lib/matplotlib/units.py:200: in get_converter
    first = cbook._safe_first_finite(x)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = []

    def _safe_first_finite(obj, *, skip_nonfinite=True):
        """
        Return the first non-None (and optionally finite) element in *obj*.
    
        This is a method for internal use.
    
        This is an type-independent way of obtaining the first non-None element,
        supporting both index access and the iterator protocol.
        The first non-None element will be obtained when skip_none is True.
        """
        def safe_isfinite(val):
            if val is None:
                return False
            try:
                return np.isfinite(val) if np.isscalar(val) else True
            except TypeError:
                # This is something that numpy can not make heads or tails
                # of, assume "finite"
                return True
        if skip_nonfinite is False:
            if isinstance(obj, collections.abc.Iterator):
                # needed to accept `array.flat` as input.
                # np.flatiter reports as an instance of collections.Iterator
                # but can still be indexed via [].
                # This has the side effect of re-setting the iterator, but
                # that is acceptable.
                try:
                    return obj[0]
                except TypeError:
                    pass
                raise RuntimeError("matplotlib does not support generators "
                                   "as input")
            return next(iter(obj))
        elif isinstance(obj, np.flatiter):
            # TODO do the finite filtering on this
            return obj[0]
        elif isinstance(obj, collections.abc.Iterator):
            raise RuntimeError("matplotlib does not "
                               "support generators as input")
        else:
            for val in obj:
                if safe_isfinite(val):
                    return val
>           raise ValueError('No finite values found in the input.')
E           ValueError: No finite values found in the input.

lib/matplotlib/cbook/__init__.py:1752: ValueError
__________________________ test_pcolormesh_small[eps] __________________________

args = ()
kwds = {'extension': 'eps', 'request': <FixtureRequest for <Function test_pcolormesh_small[eps]>>}

    @wraps(func)
    def inner(*args, **kwds):
        with self._recreate_cm():
>           return func(*args, **kwds)

/root/miniforge3/envs/matplotlib__matplotlib__3.6/lib/python3.11/contextlib.py:81: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/matplotlib/testing/compare.py:466: in compare_images
    rms = calculate_rms(expected_image, actual_image)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expected_image = array([[[255, 255, 255],
        [255, 255, 255],
        [255, 255, 255],
        ...,
        [255, 255, 255],
     ...[255, 255, 255],
        ...,
        [255, 255, 255],
        [255, 255, 255],
        [255, 255, 255]]], dtype=int16)
actual_image = array([[[255, 255, 255],
        [255, 255, 255],
        [255, 255, 255],
        ...,
        [255, 255, 255],
     ...[255, 255, 255],
        ...,
        [255, 255, 255],
        [255, 255, 255],
        [255, 255, 255]]], dtype=int16)

    def calculate_rms(expected_image, actual_image):
        """
        Calculate the per-pixel errors, then compute the root mean square error.
        """
        if expected_image.shape != actual_image.shape:
>           raise ImageComparisonFailure(
                "Image sizes do not match expected size: {} "
                "actual size {}".format(expected_image.shape, actual_image.shape))
E           matplotlib.testing.exceptions.ImageComparisonFailure: Image sizes do not match expected size: (842, 595, 3) actual size (432, 576, 3)

lib/matplotlib/testing/compare.py:363: ImageComparisonFailure
___________________________ test_bar_ticklabel_fail ____________________________

    def test_bar_ticklabel_fail():
        fig, ax = plt.subplots()
>       ax.bar([], [])

lib/matplotlib/tests/test_axes.py:1722: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/matplotlib/__init__.py:1423: in inner
    return func(ax, *map(sanitize_sequence, args), **kwargs)
lib/matplotlib/axes/_axes.py:2358: in bar
    self._process_unit_info(
lib/matplotlib/axes/_base.py:2585: in _process_unit_info
    axis.update_units(data)
lib/matplotlib/axis.py:1605: in update_units
    converter = munits.registry.get_converter(data)
lib/matplotlib/units.py:200: in get_converter
    first = cbook._safe_first_finite(x)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = []

    def _safe_first_finite(obj, *, skip_nonfinite=True):
        """
        Return the first non-None (and optionally finite) element in *obj*.
    
        This is a method for internal use.
    
        This is an type-independent way of obtaining the first non-None element,
        supporting both index access and the iterator protocol.
        The first non-None element will be obtained when skip_none is True.
        """
        def safe_isfinite(val):
            if val is None:
                return False
            try:
                return np.isfinite(val) if np.isscalar(val) else True
            except TypeError:
                # This is something that numpy can not make heads or tails
                # of, assume "finite"
                return True
        if skip_nonfinite is False:
            if isinstance(obj, collections.abc.Iterator):
                # needed to accept `array.flat` as input.
                # np.flatiter reports as an instance of collections.Iterator
                # but can still be indexed via [].
                # This has the side effect of re-setting the iterator, but
                # that is acceptable.
                try:
                    return obj[0]
                except TypeError:
                    pass
                raise RuntimeError("matplotlib does not support generators "
                                   "as input")
            return next(iter(obj))
        elif isinstance(obj, np.flatiter):
            # TODO do the finite filtering on this
            return obj[0]
        elif isinstance(obj, collections.abc.Iterator):
            raise RuntimeError("matplotlib does not "
                               "support generators as input")
        else:
            for val in obj:
                if safe_isfinite(val):
                    return val
>           raise ValueError('No finite values found in the input.')
E           ValueError: No finite values found in the input.

lib/matplotlib/cbook/__init__.py:1752: ValueError
___________________________ test_hist_bar_empty[png] ___________________________

    @image_comparison(['hist_bar_empty.png'], remove_text=True)
    def test_hist_bar_empty():
        # From #3886: creating hist from empty dataset raises ValueError
        ax = plt.gca()
>       ax.hist([], histtype='bar')

lib/matplotlib/tests/test_axes.py:2026: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/matplotlib/__init__.py:1423: in inner
    return func(ax, *map(sanitize_sequence, args), **kwargs)
lib/matplotlib/axes/_axes.py:6662: in hist
    x = [*self._process_unit_info([("x", x[0])], kwargs),
lib/matplotlib/axes/_base.py:2585: in _process_unit_info
    axis.update_units(data)
lib/matplotlib/axis.py:1605: in update_units
    converter = munits.registry.get_converter(data)
lib/matplotlib/units.py:200: in get_converter
    first = cbook._safe_first_finite(x)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = []

    def _safe_first_finite(obj, *, skip_nonfinite=True):
        """
        Return the first non-None (and optionally finite) element in *obj*.
    
        This is a method for internal use.
    
        This is an type-independent way of obtaining the first non-None element,
        supporting both index access and the iterator protocol.
        The first non-None element will be obtained when skip_none is True.
        """
        def safe_isfinite(val):
            if val is None:
                return False
            try:
                return np.isfinite(val) if np.isscalar(val) else True
            except TypeError:
                # This is something that numpy can not make heads or tails
                # of, assume "finite"
                return True
        if skip_nonfinite is False:
            if isinstance(obj, collections.abc.Iterator):
                # needed to accept `array.flat` as input.
                # np.flatiter reports as an instance of collections.Iterator
                # but can still be indexed via [].
                # This has the side effect of re-setting the iterator, but
                # that is acceptable.
                try:
                    return obj[0]
                except TypeError:
                    pass
                raise RuntimeError("matplotlib does not support generators "
                                   "as input")
            return next(iter(obj))
        elif isinstance(obj, np.flatiter):
            # TODO do the finite filtering on this
            return obj[0]
        elif isinstance(obj, collections.abc.Iterator):
            raise RuntimeError("matplotlib does not "
                               "support generators as input")
        else:
            for val in obj:
                if safe_isfinite(val):
                    return val
>           raise ValueError('No finite values found in the input.')
E           ValueError: No finite values found in the input.

lib/matplotlib/cbook/__init__.py:1752: ValueError
__________________________ test_hist_step_empty[png] ___________________________

    @image_comparison(['hist_step_empty.png'], remove_text=True)
    def test_hist_step_empty():
        # From #3886: creating hist from empty dataset raises ValueError
        ax = plt.gca()
>       ax.hist([], histtype='step')

lib/matplotlib/tests/test_axes.py:2048: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/matplotlib/__init__.py:1423: in inner
    return func(ax, *map(sanitize_sequence, args), **kwargs)
lib/matplotlib/axes/_axes.py:6662: in hist
    x = [*self._process_unit_info([("x", x[0])], kwargs),
lib/matplotlib/axes/_base.py:2585: in _process_unit_info
    axis.update_units(data)
lib/matplotlib/axis.py:1605: in update_units
    converter = munits.registry.get_converter(data)
lib/matplotlib/units.py:200: in get_converter
    first = cbook._safe_first_finite(x)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = []

    def _safe_first_finite(obj, *, skip_nonfinite=True):
        """
        Return the first non-None (and optionally finite) element in *obj*.
    
        This is a method for internal use.
    
        This is an type-independent way of obtaining the first non-None element,
        supporting both index access and the iterator protocol.
        The first non-None element will be obtained when skip_none is True.
        """
        def safe_isfinite(val):
            if val is None:
                return False
            try:
                return np.isfinite(val) if np.isscalar(val) else True
            except TypeError:
                # This is something that numpy can not make heads or tails
                # of, assume "finite"
                return True
        if skip_nonfinite is False:
            if isinstance(obj, collections.abc.Iterator):
                # needed to accept `array.flat` as input.
                # np.flatiter reports as an instance of collections.Iterator
                # but can still be indexed via [].
                # This has the side effect of re-setting the iterator, but
                # that is acceptable.
                try:
                    return obj[0]
                except TypeError:
                    pass
                raise RuntimeError("matplotlib does not support generators "
                                   "as input")
            return next(iter(obj))
        elif isinstance(obj, np.flatiter):
            # TODO do the finite filtering on this
            return obj[0]
        elif isinstance(obj, collections.abc.Iterator):
            raise RuntimeError("matplotlib does not "
                               "support generators as input")
        else:
            for val in obj:
                if safe_isfinite(val):
                    return val
>           raise ValueError('No finite values found in the input.')
E           ValueError: No finite values found in the input.

lib/matplotlib/cbook/__init__.py:1752: ValueError
_____________________ test_hist_with_empty_input[data0-1] ______________________

data = [], expected_number_of_hists = 1

    @pytest.mark.parametrize('data, expected_number_of_hists',
                             [([], 1),
                              ([[]], 1),
                              ([[], []], 2)])
    def test_hist_with_empty_input(data, expected_number_of_hists):
>       hists, _, _ = plt.hist(data)

lib/matplotlib/tests/test_axes.py:2125: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/matplotlib/pyplot.py:2563: in hist
    return gca().hist(
lib/matplotlib/__init__.py:1423: in inner
    return func(ax, *map(sanitize_sequence, args), **kwargs)
lib/matplotlib/axes/_axes.py:6662: in hist
    x = [*self._process_unit_info([("x", x[0])], kwargs),
lib/matplotlib/axes/_base.py:2585: in _process_unit_info
    axis.update_units(data)
lib/matplotlib/axis.py:1605: in update_units
    converter = munits.registry.get_converter(data)
lib/matplotlib/units.py:200: in get_converter
    first = cbook._safe_first_finite(x)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = []

    def _safe_first_finite(obj, *, skip_nonfinite=True):
        """
        Return the first non-None (and optionally finite) element in *obj*.
    
        This is a method for internal use.
    
        This is an type-independent way of obtaining the first non-None element,
        supporting both index access and the iterator protocol.
        The first non-None element will be obtained when skip_none is True.
        """
        def safe_isfinite(val):
            if val is None:
                return False
            try:
                return np.isfinite(val) if np.isscalar(val) else True
            except TypeError:
                # This is something that numpy can not make heads or tails
                # of, assume "finite"
                return True
        if skip_nonfinite is False:
            if isinstance(obj, collections.abc.Iterator):
                # needed to accept `array.flat` as input.
                # np.flatiter reports as an instance of collections.Iterator
                # but can still be indexed via [].
                # This has the side effect of re-setting the iterator, but
                # that is acceptable.
                try:
                    return obj[0]
                except TypeError:
                    pass
                raise RuntimeError("matplotlib does not support generators "
                                   "as input")
            return next(iter(obj))
        elif isinstance(obj, np.flatiter):
            # TODO do the finite filtering on this
            return obj[0]
        elif isinstance(obj, collections.abc.Iterator):
            raise RuntimeError("matplotlib does not "
                               "support generators as input")
        else:
            for val in obj:
                if safe_isfinite(val):
                    return val
>           raise ValueError('No finite values found in the input.')
E           ValueError: No finite values found in the input.

lib/matplotlib/cbook/__init__.py:1752: ValueError
______________________________ test_stairs_empty _______________________________

    def test_stairs_empty():
        ax = plt.figure().add_subplot()
>       ax.stairs([], [42])

lib/matplotlib/tests/test_axes.py:2255: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/matplotlib/__init__.py:1423: in inner
    return func(ax, *map(sanitize_sequence, args), **kwargs)
lib/matplotlib/axes/_axes.py:6964: in stairs
    edges, values, baseline = self._process_unit_info(
lib/matplotlib/axes/_base.py:2585: in _process_unit_info
    axis.update_units(data)
lib/matplotlib/axis.py:1605: in update_units
    converter = munits.registry.get_converter(data)
lib/matplotlib/units.py:200: in get_converter
    first = cbook._safe_first_finite(x)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = []

    def _safe_first_finite(obj, *, skip_nonfinite=True):
        """
        Return the first non-None (and optionally finite) element in *obj*.
    
        This is a method for internal use.
    
        This is an type-independent way of obtaining the first non-None element,
        supporting both index access and the iterator protocol.
        The first non-None element will be obtained when skip_none is True.
        """
        def safe_isfinite(val):
            if val is None:
                return False
            try:
                return np.isfinite(val) if np.isscalar(val) else True
            except TypeError:
                # This is something that numpy can not make heads or tails
                # of, assume "finite"
                return True
        if skip_nonfinite is False:
            if isinstance(obj, collections.abc.Iterator):
                # needed to accept `array.flat` as input.
                # np.flatiter reports as an instance of collections.Iterator
                # but can still be indexed via [].
                # This has the side effect of re-setting the iterator, but
                # that is acceptable.
                try:
                    return obj[0]
                except TypeError:
                    pass
                raise RuntimeError("matplotlib does not support generators "
                                   "as input")
            return next(iter(obj))
        elif isinstance(obj, np.flatiter):
            # TODO do the finite filtering on this
            return obj[0]
        elif isinstance(obj, collections.abc.Iterator):
            raise RuntimeError("matplotlib does not "
                               "support generators as input")
        else:
            for val in obj:
                if safe_isfinite(val):
                    return val
>           raise ValueError('No finite values found in the input.')
E           ValueError: No finite values found in the input.

lib/matplotlib/cbook/__init__.py:1752: ValueError
__________________________ test_contour_colorbar[png] __________________________

    @image_comparison(['contour_colorbar'], style='mpl20')
    def test_contour_colorbar():
        x, y, z = contour_dat()
    
        fig, ax = plt.subplots()
        cs = ax.contourf(x, y, z, levels=np.arange(-1.8, 1.801, 0.2),
                         cmap=mpl.colormaps['RdBu'],
                         vmin=-0.6,
                         vmax=0.6,
                         extend='both')
        cs1 = ax.contour(x, y, z, levels=np.arange(-2.2, -0.599, 0.2),
                         colors=['y'],
                         linestyles='solid',
                         linewidths=2)
        cs2 = ax.contour(x, y, z, levels=np.arange(0.6, 2.2, 0.2),
                         colors=['c'],
                         linewidths=2)
>       cbar = fig.colorbar(cs, ax=ax)

lib/matplotlib/tests/test_axes.py:2360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/matplotlib/figure.py:1278: in colorbar
    cb = cbar.Colorbar(cax, mappable, **cb_kw)
lib/matplotlib/_api/deprecation.py:384: in wrapper
    return func(*inner_args, **inner_kwargs)
lib/matplotlib/colorbar.py:396: in __init__
    self._draw_all()
lib/matplotlib/colorbar.py:523: in _draw_all
    self._short_axis().set_ticks([])
lib/matplotlib/axis.py:2033: in set_ticks
    result = self._set_tick_locations(ticks, minor=minor)
lib/matplotlib/axis.py:1977: in _set_tick_locations
    ticks = self.convert_units(ticks)
lib/matplotlib/axis.py:1663: in convert_units
    self.converter = munits.registry.get_converter(x)
lib/matplotlib/units.py:200: in get_converter
    first = cbook._safe_first_finite(x)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = []

    def _safe_first_finite(obj, *, skip_nonfinite=True):
        """
        Return the first non-None (and optionally finite) element in *obj*.
    
        This is a method for internal use.
    
        This is an type-independent way of obtaining the first non-None element,
        supporting both index access and the iterator protocol.
        The first non-None element will be obtained when skip_none is True.
        """
        def safe_isfinite(val):
            if val is None:
                return False
            try:
                return np.isfinite(val) if np.isscalar(val) else True
            except TypeError:
                # This is something that numpy can not make heads or tails
                # of, assume "finite"
                return True
        if skip_nonfinite is False:
            if isinstance(obj, collections.abc.Iterator):
                # needed to accept `array.flat` as input.
                # np.flatiter reports as an instance of collections.Iterator
                # but can still be indexed via [].
                # This has the side effect of re-setting the iterator, but
                # that is acceptable.
                try:
                    return obj[0]
                except TypeError:
                    pass
                raise RuntimeError("matplotlib does not support generators "
                                   "as input")
            return next(iter(obj))
        elif isinstance(obj, np.flatiter):
            # TODO do the finite filtering on this
            return obj[0]
        elif isinstance(obj, collections.abc.Iterator):
            raise RuntimeError("matplotlib does not "
                               "support generators as input")
        else:
            for val in obj:
                if safe_isfinite(val):
                    return val
>           raise ValueError('No finite values found in the input.')
E           ValueError: No finite values found in the input.

lib/matplotlib/cbook/__init__.py:1752: ValueError
__________________________ test_contour_colorbar[pdf] __________________________

    @image_comparison(['contour_colorbar'], style='mpl20')
    def test_contour_colorbar():
        x, y, z = contour_dat()
    
        fig, ax = plt.subplots()
        cs = ax.contourf(x, y, z, levels=np.arange(-1.8, 1.801, 0.2),
                         cmap=mpl.colormaps['RdBu'],
                         vmin=-0.6,
                         vmax=0.6,
                         extend='both')
        cs1 = ax.contour(x, y, z, levels=np.arange(-2.2, -0.599, 0.2),
                         colors=['y'],
                         linestyles='solid',
                         linewidths=2)
        cs2 = ax.contour(x, y, z, levels=np.arange(0.6, 2.2, 0.2),
                         colors=['c'],
                         linewidths=2)
>       cbar = fig.colorbar(cs, ax=ax)

lib/matplotlib/tests/test_axes.py:2360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/matplotlib/figure.py:1278: in colorbar
    cb = cbar.Colorbar(cax, mappable, **cb_kw)
lib/matplotlib/_api/deprecation.py:384: in wrapper
    return func(*inner_args, **inner_kwargs)
lib/matplotlib/colorbar.py:396: in __init__
    self._draw_all()
lib/matplotlib/colorbar.py:523: in _draw_all
    self._short_axis().set_ticks([])
lib/matplotlib/axis.py:2033: in set_ticks
    result = self._set_tick_locations(ticks, minor=minor)
lib/matplotlib/axis.py:1977: in _set_tick_locations
    ticks = self.convert_units(ticks)
lib/matplotlib/axis.py:1663: in convert_units
    self.converter = munits.registry.get_converter(x)
lib/matplotlib/units.py:200: in get_converter
    first = cbook._safe_first_finite(x)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = []

    def _safe_first_finite(obj, *, skip_nonfinite=True):
        """
        Return the first non-None (and optionally finite) element in *obj*.
    
        This is a method for internal use.
    
        This is an type-independent way of obtaining the first non-None element,
        supporting both index access and the iterator protocol.
        The first non-None element will be obtained when skip_none is True.
        """
        def safe_isfinite(val):
            if val is None:
                return False
            try:
                return np.isfinite(val) if np.isscalar(val) else True
            except TypeError:
                # This is something that numpy can not make heads or tails
                # of, assume "finite"
                return True
        if skip_nonfinite is False:
            if isinstance(obj, collections.abc.Iterator):
                # needed to accept `array.flat` as input.
                # np.flatiter reports as an instance of collections.Iterator
                # but can still be indexed via [].
                # This has the side effect of re-setting the iterator, but
                # that is acceptable.
                try:
                    return obj[0]
                except TypeError:
                    pass
                raise RuntimeError("matplotlib does not support generators "
                                   "as input")
            return next(iter(obj))
        elif isinstance(obj, np.flatiter):
            # TODO do the finite filtering on this
            return obj[0]
        elif isinstance(obj, collections.abc.Iterator):
            raise RuntimeError("matplotlib does not "
                               "support generators as input")
        else:
            for val in obj:
                if safe_isfinite(val):
                    return val
>           raise ValueError('No finite values found in the input.')
E           ValueError: No finite values found in the input.

lib/matplotlib/cbook/__init__.py:1752: ValueError
__________________________ test_contour_colorbar[svg] __________________________

    @image_comparison(['contour_colorbar'], style='mpl20')
    def test_contour_colorbar():
        x, y, z = contour_dat()
    
        fig, ax = plt.subplots()
        cs = ax.contourf(x, y, z, levels=np.arange(-1.8, 1.801, 0.2),
                         cmap=mpl.colormaps['RdBu'],
                         vmin=-0.6,
                         vmax=0.6,
                         extend='both')
        cs1 = ax.contour(x, y, z, levels=np.arange(-2.2, -0.599, 0.2),
                         colors=['y'],
                         linestyles='solid',
                         linewidths=2)
        cs2 = ax.contour(x, y, z, levels=np.arange(0.6, 2.2, 0.2),
                         colors=['c'],
                         linewidths=2)
>       cbar = fig.colorbar(cs, ax=ax)

lib/matplotlib/tests/test_axes.py:2360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/matplotlib/figure.py:1278: in colorbar
    cb = cbar.Colorbar(cax, mappable, **cb_kw)
lib/matplotlib/_api/deprecation.py:384: in wrapper
    return func(*inner_args, **inner_kwargs)
lib/matplotlib/colorbar.py:396: in __init__
    self._draw_all()
lib/matplotlib/colorbar.py:523: in _draw_all
    self._short_axis().set_ticks([])
lib/matplotlib/axis.py:2033: in set_ticks
    result = self._set_tick_locations(ticks, minor=minor)
lib/matplotlib/axis.py:1977: in _set_tick_locations
    ticks = self.convert_units(ticks)
lib/matplotlib/axis.py:1663: in convert_units
    self.converter = munits.registry.get_converter(x)
lib/matplotlib/units.py:200: in get_converter
    first = cbook._safe_first_finite(x)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = []

    def _safe_first_finite(obj, *, skip_nonfinite=True):
        """
        Return the first non-None (and optionally finite) element in *obj*.
    
        This is a method for internal use.
    
        This is an type-independent way of obtaining the first non-None element,
        supporting both index access and the iterator protocol.
        The first non-None element will be obtained when skip_none is True.
        """
        def safe_isfinite(val):
            if val is None:
                return False
            try:
                return np.isfinite(val) if np.isscalar(val) else True
            except TypeError:
                # This is something that numpy can not make heads or tails
                # of, assume "finite"
                return True
        if skip_nonfinite is False:
            if isinstance(obj, collections.abc.Iterator):
                # needed to accept `array.flat` as input.
                # np.flatiter reports as an instance of collections.Iterator
                # but can still be indexed via [].
                # This has the side effect of re-setting the iterator, but
                # that is acceptable.
                try:
                    return obj[0]
                except TypeError:
                    pass
                raise RuntimeError("matplotlib does not support generators "
                                   "as input")
            return next(iter(obj))
        elif isinstance(obj, np.flatiter):
            # TODO do the finite filtering on this
            return obj[0]
        elif isinstance(obj, collections.abc.Iterator):
            raise RuntimeError("matplotlib does not "
                               "support generators as input")
        else:
            for val in obj:
                if safe_isfinite(val):
                    return val
>           raise ValueError('No finite values found in the input.')
E           ValueError: No finite values found in the input.

lib/matplotlib/cbook/__init__.py:1752: ValueError
_______________ TestScatter.test_scatter_color_warning[kwargs0] ________________

self = <matplotlib.tests.test_axes.TestScatter object at 0x7fa0d7531510>
kwargs = {'cmap': 'gray'}

    @pytest.mark.parametrize('kwargs',
                                [
                                    {'cmap': 'gray'},
                                    {'norm': mcolors.Normalize()},
                                    {'vmin': 0},
                                    {'vmax': 0}
                                ])
    def test_scatter_color_warning(self, kwargs):
        warn_match = "No data for colormapping provided "
        # Warn for cases where 'cmap', 'norm', 'vmin', 'vmax'
        # kwargs are being overridden
        with pytest.warns(Warning, match=warn_match):
>           plt.scatter([], [], **kwargs)

lib/matplotlib/tests/test_axes.py:2484: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/matplotlib/pyplot.py:2780: in scatter
    __ret = gca().scatter(
lib/matplotlib/__init__.py:1423: in inner
    return func(ax, *map(sanitize_sequence, args), **kwargs)
lib/matplotlib/axes/_axes.py:4540: in scatter
    x, y = self._process_unit_info([("x", x), ("y", y)], kwargs)
lib/matplotlib/axes/_base.py:2585: in _process_unit_info
    axis.update_units(data)
lib/matplotlib/axis.py:1605: in update_units
    converter = munits.registry.get_converter(data)
lib/matplotlib/units.py:200: in get_converter
    first = cbook._safe_first_finite(x)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = []

    def _safe_first_finite(obj, *, skip_nonfinite=True):
        """
        Return the first non-None (and optionally finite) element in *obj*.
    
        This is a method for internal use.
    
        This is an type-independent way of obtaining the first non-None element,
        supporting both index access and the iterator protocol.
        The first non-None element will be obtained when skip_none is True.
        """
        def safe_isfinite(val):
            if val is None:
                return False
            try:
                return np.isfinite(val) if np.isscalar(val) else True
            except TypeError:
                # This is something that numpy can not make heads or tails
                # of, assume "finite"
                return True
        if skip_nonfinite is False:
            if isinstance(obj, collections.abc.Iterator):
                # needed to accept `array.flat` as input.
                # np.flatiter reports as an instance of collections.Iterator
                # but can still be indexed via [].
                # This has the side effect of re-setting the iterator, but
                # that is acceptable.
                try:
                    return obj[0]
                except TypeError:
                    pass
                raise RuntimeError("matplotlib does not support generators "
                                   "as input")
            return next(iter(obj))
        elif isinstance(obj, np.flatiter):
            # TODO do the finite filtering on this
            return obj[0]
        elif isinstance(obj, collections.abc.Iterator):
            raise RuntimeError("matplotlib does not "
                               "support generators as input")
        else:
            for val in obj:
                if safe_isfinite(val):
                    return val
>           raise ValueError('No finite values found in the input.')
E           ValueError: No finite values found in the input.

lib/matplotlib/cbook/__init__.py:1752: ValueError

During handling of the above exception, another exception occurred:

self = <matplotlib.tests.test_axes.TestScatter object at 0x7fa0d7531510>
kwargs = {'cmap': 'gray'}

    @pytest.mark.parametrize('kwargs',
                                [
                                    {'cmap': 'gray'},
                                    {'norm': mcolors.Normalize()},
                                    {'vmin': 0},
                                    {'vmax': 0}
                                ])
    def test_scatter_color_warning(self, kwargs):
        warn_match = "No data for colormapping provided "
        # Warn for cases where 'cmap', 'norm', 'vmin', 'vmax'
        # kwargs are being overridden
>       with pytest.warns(Warning, match=warn_match):
E       Failed: DID NOT WARN. No warnings of type (<class 'Warning'>,) were emitted.
E        Emitted warnings: [].

lib/matplotlib/tests/test_axes.py:2483: Failed
_______________ TestScatter.test_scatter_color_warning[kwargs1] ________________

self = <matplotlib.tests.test_axes.TestScatter object at 0x7fa0d7531790>
kwargs = {'norm': <matplotlib.colors.Normalize object at 0x7fa0dcac9690>}

    @pytest.mark.parametrize('kwargs',
                                [
                                    {'cmap': 'gray'},
                                    {'norm': mcolors.Normalize()},
                                    {'vmin': 0},
                                    {'vmax': 0}
                                ])
    def test_scatter_color_warning(self, kwargs):
        warn_match = "No data for colormapping provided "
        # Warn for cases where 'cmap', 'norm', 'vmin', 'vmax'
        # kwargs are being overridden
        with pytest.warns(Warning, match=warn_match):
>           plt.scatter([], [], **kwargs)

lib/matplotlib/tests/test_axes.py:2484: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/matplotlib/pyplot.py:2780: in scatter
    __ret = gca().scatter(
lib/matplotlib/__init__.py:1423: in inner
    return func(ax, *map(sanitize_sequence, args), **kwargs)
lib/matplotlib/axes/_axes.py:4540: in scatter
    x, y = self._process_unit_info([("x", x), ("y", y)], kwargs)
lib/matplotlib/axes/_base.py:2585: in _process_unit_info
    axis.update_units(data)
lib/matplotlib/axis.py:1605: in update_units
    converter = munits.registry.get_converter(data)
lib/matplotlib/units.py:200: in get_converter
    first = cbook._safe_first_finite(x)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = []

    def _safe_first_finite(obj, *, skip_nonfinite=True):
        """
        Return the first non-None (and optionally finite) element in *obj*.
    
        This is a method for internal use.
    
        This is an type-independent way of obtaining the first non-None element,
        supporting both index access and the iterator protocol.
        The first non-None element will be obtained when skip_none is True.
        """
        def safe_isfinite(val):
            if val is None:
                return False
            try:
                return np.isfinite(val) if np.isscalar(val) else True
            except TypeError:
                # This is something that numpy can not make heads or tails
                # of, assume "finite"
                return True
        if skip_nonfinite is False:
            if isinstance(obj, collections.abc.Iterator):
                # needed to accept `array.flat` as input.
                # np.flatiter reports as an instance of collections.Iterator
                # but can still be indexed via [].
                # This has the side effect of re-setting the iterator, but
                # that is acceptable.
                try:
                    return obj[0]
                except TypeError:
                    pass
                raise RuntimeError("matplotlib does not support generators "
                                   "as input")
            return next(iter(obj))
        elif isinstance(obj, np.flatiter):
            # TODO do the finite filtering on this
            return obj[0]
        elif isinstance(obj, collections.abc.Iterator):
            raise RuntimeError("matplotlib does not "
                               "support generators as input")
        else:
            for val in obj:
                if safe_isfinite(val):
                    return val
>           raise ValueError('No finite values found in the input.')
E           ValueError: No finite values found in the input.

lib/matplotlib/cbook/__init__.py:1752: ValueError

During handling of the above exception, another exception occurred:

self = <matplotlib.tests.test_axes.TestScatter object at 0x7fa0d7531790>
kwargs = {'norm': <matplotlib.colors.Normalize object at 0x7fa0dcac9690>}

    @pytest.mark.parametrize('kwargs',
                                [
                                    {'cmap': 'gray'},
                                    {'norm': mcolors.Normalize()},
                                    {'vmin': 0},
                                    {'vmax': 0}
                                ])
    def test_scatter_color_warning(self, kwargs):
        warn_match = "No data for colormapping provided "
        # Warn for cases where 'cmap', 'norm', 'vmin', 'vmax'
        # kwargs are being overridden
>       with pytest.warns(Warning, match=warn_match):
E       Failed: DID NOT WARN. No warnings of type (<class 'Warning'>,) were emitted.
E        Emitted warnings: [].

lib/matplotlib/tests/test_axes.py:2483: Failed
_______________ TestScatter.test_scatter_color_warning[kwargs2] ________________

self = <matplotlib.tests.test_axes.TestScatter object at 0x7fa0d7531a10>
kwargs = {'vmin': 0}

    @pytest.mark.parametrize('kwargs',
                                [
                                    {'cmap': 'gray'},
                                    {'norm': mcolors.Normalize()},
                                    {'vmin': 0},
                                    {'vmax': 0}
                                ])
    def test_scatter_color_warning(self, kwargs):
        warn_match = "No data for colormapping provided "
        # Warn for cases where 'cmap', 'norm', 'vmin', 'vmax'
        # kwargs are being overridden
        with pytest.warns(Warning, match=warn_match):
>           plt.scatter([], [], **kwargs)

lib/matplotlib/tests/test_axes.py:2484: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/matplotlib/pyplot.py:2780: in scatter
    __ret = gca().scatter(
lib/matplotlib/__init__.py:1423: in inner
    return func(ax, *map(sanitize_sequence, args), **kwargs)
lib/matplotlib/axes/_axes.py:4540: in scatter
    x, y = self._process_unit_info([("x", x), ("y", y)], kwargs)
lib/matplotlib/axes/_base.py:2585: in _process_unit_info
    axis.update_units(data)
lib/matplotlib/axis.py:1605: in update_units
    converter = munits.registry.get_converter(data)
lib/matplotlib/units.py:200: in get_converter
    first = cbook._safe_first_finite(x)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = []

    def _safe_first_finite(obj, *, skip_nonfinite=True):
        """
        Return the first non-None (and optionally finite) element in *obj*.
    
        This is a method for internal use.
    
        This is an type-independent way of obtaining the first non-None element,
        supporting both index access and the iterator protocol.
        The first non-None element will be obtained when skip_none is True.
        """
        def safe_isfinite(val):
            if val is None:
                return False
            try:
                return np.isfinite(val) if np.isscalar(val) else True
            except TypeError:
                # This is something that numpy can not make heads or tails
                # of, assume "finite"
                return True
        if skip_nonfinite is False:
            if isinstance(obj, collections.abc.Iterator):
                # needed to accept `array.flat` as input.
                # np.flatiter reports as an instance of collections.Iterator
                # but can still be indexed via [].
                # This has the side effect of re-setting the iterator, but
                # that is acceptable.
                try:
                    return obj[0]
                except TypeError:
                    pass
                raise RuntimeError("matplotlib does not support generators "
                                   "as input")
            return next(iter(obj))
        elif isinstance(obj, np.flatiter):
            # TODO do the finite filtering on this
            return obj[0]
        elif isinstance(obj, collections.abc.Iterator):
            raise RuntimeError("matplotlib does not "
                               "support generators as input")
        else:
            for val in obj:
                if safe_isfinite(val):
                    return val
>           raise ValueError('No finite values found in the input.')
E           ValueError: No finite values found in the input.

lib/matplotlib/cbook/__init__.py:1752: ValueError

During handling of the above exception, another exception occurred:

self = <matplotlib.tests.test_axes.TestScatter object at 0x7fa0d7531a10>
kwargs = {'vmin': 0}

    @pytest.mark.parametrize('kwargs',
                                [
                                    {'cmap': 'gray'},
                                    {'norm': mcolors.Normalize()},
                                    {'vmin': 0},
                                    {'vmax': 0}
                                ])
    def test_scatter_color_warning(self, kwargs):
        warn_match = "No data for colormapping provided "
        # Warn for cases where 'cmap', 'norm', 'vmin', 'vmax'
        # kwargs are being overridden
>       with pytest.warns(Warning, match=warn_match):
E       Failed: DID NOT WARN. No warnings of type (<class 'Warning'>,) were emitted.
E        Emitted warnings: [].

lib/matplotlib/tests/test_axes.py:2483: Failed
_______________ TestScatter.test_scatter_color_warning[kwargs3] ________________

self = <matplotlib.tests.test_axes.TestScatter object at 0x7fa0d7531c90>
kwargs = {'vmax': 0}

    @pytest.mark.parametrize('kwargs',
                                [
                                    {'cmap': 'gray'},
                                    {'norm': mcolors.Normalize()},
                                    {'vmin': 0},
                                    {'vmax': 0}
                                ])
    def test_scatter_color_warning(self, kwargs):
        warn_match = "No data for colormapping provided "
        # Warn for cases where 'cmap', 'norm', 'vmin', 'vmax'
        # kwargs are being overridden
        with pytest.warns(Warning, match=warn_match):
>           plt.scatter([], [], **kwargs)

lib/matplotlib/tests/test_axes.py:2484: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/matplotlib/pyplot.py:2780: in scatter
    __ret = gca().scatter(
lib/matplotlib/__init__.py:1423: in inner
    return func(ax, *map(sanitize_sequence, args), **kwargs)
lib/matplotlib/axes/_axes.py:4540: in scatter
    x, y = self._process_unit_info([("x", x), ("y", y)], kwargs)
lib/matplotlib/axes/_base.py:2585: in _process_unit_info
    axis.update_units(data)
lib/matplotlib/axis.py:1605: in update_units
    converter = munits.registry.get_converter(data)
lib/matplotlib/units.py:200: in get_converter
    first = cbook._safe_first_finite(x)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = []

    def _safe_first_finite(obj, *, skip_nonfinite=True):
        """
        Return the first non-None (and optionally finite) element in *obj*.
    
        This is a method for internal use.
    
        This is an type-independent way of obtaining the first non-None element,
        supporting both index access and the iterator protocol.
        The first non-None element will be obtained when skip_none is True.
        """
        def safe_isfinite(val):
            if val is None:
                return False
            try:
                return np.isfinite(val) if np.isscalar(val) else True
            except TypeError:
                # This is something that numpy can not make heads or tails
                # of, assume "finite"
                return True
        if skip_nonfinite is False:
            if isinstance(obj, collections.abc.Iterator):
                # needed to accept `array.flat` as input.
                # np.flatiter reports as an instance of collections.Iterator
                # but can still be indexed via [].
                # This has the side effect of re-setting the iterator, but
                # that is acceptable.
                try:
                    return obj[0]
                except TypeError:
                    pass
                raise RuntimeError("matplotlib does not support generators "
                                   "as input")
            return next(iter(obj))
        elif isinstance(obj, np.flatiter):
            # TODO do the finite filtering on this
            return obj[0]
        elif isinstance(obj, collections.abc.Iterator):
            raise RuntimeError("matplotlib does not "
                               "support generators as input")
        else:
            for val in obj:
                if safe_isfinite(val):
                    return val
>           raise ValueError('No finite values found in the input.')
E           ValueError: No finite values found in the input.

lib/matplotlib/cbook/__init__.py:1752: ValueError

During handling of the above exception, another exception occurred:

self = <matplotlib.tests.test_axes.TestScatter object at 0x7fa0d7531c90>
kwargs = {'vmax': 0}

    @pytest.mark.parametrize('kwargs',
                                [
                                    {'cmap': 'gray'},
                                    {'norm': mcolors.Normalize()},
                                    {'vmin': 0},
                                    {'vmax': 0}
                                ])
    def test_scatter_color_warning(self, kwargs):
        warn_match = "No data for colormapping provided "
        # Warn for cases where 'cmap', 'norm', 'vmin', 'vmax'
        # kwargs are being overridden
>       with pytest.warns(Warning, match=warn_match):
E       Failed: DID NOT WARN. No warnings of type (<class 'Warning'>,) were emitted.
E        Emitted warnings: [].

lib/matplotlib/tests/test_axes.py:2483: Failed
___________________________ test_psd_csd_edge_cases ____________________________

    def test_psd_csd_edge_cases():
        # Inverted yaxis or fully zero inputs used to throw exceptions.
        axs = plt.figure().subplots(2)
        for ax in axs:
            ax.yaxis.set(inverted=True)
        with np.errstate(divide="ignore"):
>           axs[0].psd(np.zeros(5))

lib/matplotlib/tests/test_axes.py:5184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/matplotlib/__init__.py:1423: in inner
    return func(ax, *map(sanitize_sequence, args), **kwargs)
lib/matplotlib/axes/_axes.py:7188: in psd
    line = self.plot(freqs, 10 * np.log10(pxx), **kwargs)
lib/matplotlib/axes/_axes.py:1662: in plot
    lines = [*self._get_lines(*args, data=data, **kwargs)]
lib/matplotlib/axes/_base.py:311: in __call__
    yield from self._plot_args(
lib/matplotlib/axes/_base.py:501: in _plot_args
    self.axes.yaxis.update_units(y)
lib/matplotlib/axis.py:1605: in update_units
    converter = munits.registry.get_converter(data)
lib/matplotlib/units.py:200: in get_converter
    first = cbook._safe_first_finite(x)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = array([-inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf,
       -inf, -inf, -inf, -inf, -inf, -inf, -i...nf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf,
       -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf])

    def _safe_first_finite(obj, *, skip_nonfinite=True):
        """
        Return the first non-None (and optionally finite) element in *obj*.
    
        This is a method for internal use.
    
        This is an type-independent way of obtaining the first non-None element,
        supporting both index access and the iterator protocol.
        The first non-None element will be obtained when skip_none is True.
        """
        def safe_isfinite(val):
            if val is None:
                return False
            try:
                return np.isfinite(val) if np.isscalar(val) else True
            except TypeError:
                # This is something that numpy can not make heads or tails
                # of, assume "finite"
                return True
        if skip_nonfinite is False:
            if isinstance(obj, collections.abc.Iterator):
                # needed to accept `array.flat` as input.
                # np.flatiter reports as an instance of collections.Iterator
                # but can still be indexed via [].
                # This has the side effect of re-setting the iterator, but
                # that is acceptable.
                try:
                    return obj[0]
                except TypeError:
                    pass
                raise RuntimeError("matplotlib does not support generators "
                                   "as input")
            return next(iter(obj))
        elif isinstance(obj, np.flatiter):
            # TODO do the finite filtering on this
            return obj[0]
        elif isinstance(obj, collections.abc.Iterator):
            raise RuntimeError("matplotlib does not "
                               "support generators as input")
        else:
            for val in obj:
                if safe_isfinite(val):
                    return val
>           raise ValueError('No finite values found in the input.')
E           ValueError: No finite values found in the input.

lib/matplotlib/cbook/__init__.py:1752: ValueError
_ test_axis_errors[TypeError-args3-kwargs3-axis\\(\\) got an unexpected keyword argument 'foo'] _

err = <class 'TypeError'>, args = (), kwargs = {'foo': None}
match = "axis\\(\\) got an unexpected keyword argument 'foo'"

    @pytest.mark.parametrize('err, args, kwargs, match',
                             ((TypeError, (1, 2), {},
                               r"axis\(\) takes 0 or 1 positional arguments but 2"
                               " were given"),
                              (ValueError, ('foo', ), {},
                               "Unrecognized string 'foo' to axis; try 'on' or "
                               "'off'"),
                              (TypeError, ([1, 2], ), {},
                               "the first argument to axis*"),
                              (TypeError, tuple(), {'foo': None},
                               r"axis\(\) got an unexpected keyword argument "
                               "'foo'"),
                              ))
    def test_axis_errors(err, args, kwargs, match):
        with pytest.raises(err, match=match):
>           plt.axis(*args, **kwargs)

lib/matplotlib/tests/test_axes.py:5445: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/matplotlib/pyplot.py:2331: in axis
    return gca().axis(*args, emit=emit, **kwargs)
lib/matplotlib/axes/_base.py:2144: in axis
    self.set_xlim(xmin, xmax, emit=emit, auto=xauto)
lib/matplotlib/_api/deprecation.py:454: in wrapper
    return func(*args, **kwargs)
lib/matplotlib/axes/_base.py:3693: in set_xlim
    return self.xaxis._set_lim(left, right, emit=emit, auto=auto)
lib/matplotlib/axis.py:1114: in _set_lim
    self.axes._process_unit_info([(name, (v0, v1))], convert=False)
lib/matplotlib/axes/_base.py:2585: in _process_unit_info
    axis.update_units(data)
lib/matplotlib/axis.py:1605: in update_units
    converter = munits.registry.get_converter(data)
lib/matplotlib/units.py:200: in get_converter
    first = cbook._safe_first_finite(x)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = (None, None)

    def _safe_first_finite(obj, *, skip_nonfinite=True):
        """
        Return the first non-None (and optionally finite) element in *obj*.
    
        This is a method for internal use.
    
        This is an type-independent way of obtaining the first non-None element,
        supporting both index access and the iterator protocol.
        The first non-None element will be obtained when skip_none is True.
        """
        def safe_isfinite(val):
            if val is None:
                return False
            try:
                return np.isfinite(val) if np.isscalar(val) else True
            except TypeError:
                # This is something that numpy can not make heads or tails
                # of, assume "finite"
                return True
        if skip_nonfinite is False:
            if isinstance(obj, collections.abc.Iterator):
                # needed to accept `array.flat` as input.
                # np.flatiter reports as an instance of collections.Iterator
                # but can still be indexed via [].
                # This has the side effect of re-setting the iterator, but
                # that is acceptable.
                try:
                    return obj[0]
                except TypeError:
                    pass
                raise RuntimeError("matplotlib does not support generators "
                                   "as input")
            return next(iter(obj))
        elif isinstance(obj, np.flatiter):
            # TODO do the finite filtering on this
            return obj[0]
        elif isinstance(obj, collections.abc.Iterator):
            raise RuntimeError("matplotlib does not "
                               "support generators as input")
        else:
            for val in obj:
                if safe_isfinite(val):
                    return val
>           raise ValueError('No finite values found in the input.')
E           ValueError: No finite values found in the input.

lib/matplotlib/cbook/__init__.py:1752: ValueError
____________________________ test_pie_default[png] _____________________________

    @image_comparison(['pie_default.png'])
    def test_pie_default():
        # The slices will be ordered and plotted counter-clockwise.
        labels = 'Frogs', 'Hogs', 'Dogs', 'Logs'
        sizes = [15, 30, 45, 10]
        colors = ['yellowgreen', 'gold', 'lightskyblue', 'lightcoral']
        explode = (0, 0.1, 0, 0)  # only "explode" the 2nd slice (i.e. 'Hogs')
        fig1, ax1 = plt.subplots(figsize=(8, 6))
>       ax1.pie(sizes, explode=explode, labels=labels, colors=colors,
                autopct='%1.1f%%', shadow=True, startangle=90)

lib/matplotlib/tests/test_axes.py:5528: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/matplotlib/__init__.py:1423: in inner
    return func(ax, *map(sanitize_sequence, args), **kwargs)
lib/matplotlib/axes/_axes.py:3268: in pie
    self.set(frame_on=False, xticks=[], yticks=[],
lib/matplotlib/artist.py:117: in <lambda>
    cls.set = lambda self, **kwargs: Artist.set(self, **kwargs)
lib/matplotlib/artist.py:1194: in set
    return self._internal_update(cbook.normalize_kwargs(kwargs, self))
lib/matplotlib/artist.py:1186: in _internal_update
    return self._update_props(
lib/matplotlib/artist.py:1162: in _update_props
    ret.append(func(v))
lib/matplotlib/axes/_base.py:73: in wrapper
    return get_method(self)(*args, **kwargs)
lib/matplotlib/axis.py:2033: in set_ticks
    result = self._set_tick_locations(ticks, minor=minor)
lib/matplotlib/axis.py:1977: in _set_tick_locations
    ticks = self.convert_units(ticks)
lib/matplotlib/axis.py:1663: in convert_units
    self.converter = munits.registry.get_converter(x)
lib/matplotlib/units.py:200: in get_converter
    first = cbook._safe_first_finite(x)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = []

    def _safe_first_finite(obj, *, skip_nonfinite=True):
        """
        Return the first non-None (and optionally finite) element in *obj*.
    
        This is a method for internal use.
    
        This is an type-independent way of obtaining the first non-None element,
        supporting both index access and the iterator protocol.
        The first non-None element will be obtained when skip_none is True.
        """
        def safe_isfinite(val):
            if val is None:
                return False
            try:
                return np.isfinite(val) if np.isscalar(val) else True
            except TypeError:
                # This is something that numpy can not make heads or tails
                # of, assume "finite"
                return True
        if skip_nonfinite is False:
            if isinstance(obj, collections.abc.Iterator):
                # needed to accept `array.flat` as input.
                # np.flatiter reports as an instance of collections.Iterator
                # but can still be indexed via [].
                # This has the side effect of re-setting the iterator, but
                # that is acceptable.
                try:
                    return obj[0]
                except TypeError:
                    pass
                raise RuntimeError("matplotlib does not support generators "
                                   "as input")
            return next(iter(obj))
        elif isinstance(obj, np.flatiter):
            # TODO do the finite filtering on this
            return obj[0]
        elif isinstance(obj, collections.abc.Iterator):
            raise RuntimeError("matplotlib does not "
                               "support generators as input")
        else:
            for val in obj:
                if safe_isfinite(val):
                    return val
>           raise ValueError('No finite values found in the input.')
E           ValueError: No finite values found in the input.

lib/matplotlib/cbook/__init__.py:1752: ValueError
__________________________ test_pie_linewidth_0[png] ___________________________

    @image_comparison(['pie_linewidth_0', 'pie_linewidth_0', 'pie_linewidth_0'],
                      extensions=['png'], style='mpl20')
    def test_pie_linewidth_0():
        # The slices will be ordered and plotted counter-clockwise.
        labels = 'Frogs', 'Hogs', 'Dogs', 'Logs'
        sizes = [15, 30, 45, 10]
        colors = ['yellowgreen', 'gold', 'lightskyblue', 'lightcoral']
        explode = (0, 0.1, 0, 0)  # only "explode" the 2nd slice (i.e. 'Hogs')
    
>       plt.pie(sizes, explode=explode, labels=labels, colors=colors,
                autopct='%1.1f%%', shadow=True, startangle=90,
                wedgeprops={'linewidth': 0})

lib/matplotlib/tests/test_axes.py:5541: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/matplotlib/pyplot.py:2717: in pie
    return gca().pie(
lib/matplotlib/__init__.py:1423: in inner
    return func(ax, *map(sanitize_sequence, args), **kwargs)
lib/matplotlib/axes/_axes.py:3268: in pie
    self.set(frame_on=False, xticks=[], yticks=[],
lib/matplotlib/artist.py:117: in <lambda>
    cls.set = lambda self, **kwargs: Artist.set(self, **kwargs)
lib/matplotlib/artist.py:1194: in set
    return self._internal_update(cbook.normalize_kwargs(kwargs, self))
lib/matplotlib/artist.py:1186: in _internal_update
    return self._update_props(
lib/matplotlib/artist.py:1162: in _update_props
    ret.append(func(v))
lib/matplotlib/axes/_base.py:73: in wrapper
    return get_method(self)(*args, **kwargs)
lib/matplotlib/axis.py:2033: in set_ticks
    result = self._set_tick_locations(ticks, minor=minor)
lib/matplotlib/axis.py:1977: in _set_tick_locations
    ticks = self.convert_units(ticks)
lib/matplotlib/axis.py:1663: in convert_units
    self.converter = munits.registry.get_converter(x)
lib/matplotlib/units.py:200: in get_converter
    first = cbook._safe_first_finite(x)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = []

    def _safe_first_finite(obj, *, skip_nonfinite=True):
        """
        Return the first non-None (and optionally finite) element in *obj*.
    
        This is a method for internal use.
    
        This is an type-independent way of obtaining the first non-None element,
        supporting both index access and the iterator protocol.
        The first non-None element will be obtained when skip_none is True.
        """
        def safe_isfinite(val):
            if val is None:
                return False
            try:
                return np.isfinite(val) if np.isscalar(val) else True
            except TypeError:
                # This is something that numpy can not make heads or tails
                # of, assume "finite"
                return True
        if skip_nonfinite is False:
            if isinstance(obj, collections.abc.Iterator):
                # needed to accept `array.flat` as input.
                # np.flatiter reports as an instance of collections.Iterator
                # but can still be indexed via [].
                # This has the side effect of re-setting the iterator, but
                # that is acceptable.
                try:
                    return obj[0]
                except TypeError:
                    pass
                raise RuntimeError("matplotlib does not support generators "
                                   "as input")
            return next(iter(obj))
        elif isinstance(obj, np.flatiter):
            # TODO do the finite filtering on this
            return obj[0]
        elif isinstance(obj, collections.abc.Iterator):
            raise RuntimeError("matplotlib does not "
                               "support generators as input")
        else:
            for val in obj:
                if safe_isfinite(val):
                    return val
>           raise ValueError('No finite values found in the input.')
E           ValueError: No finite values found in the input.

lib/matplotlib/cbook/__init__.py:1752: ValueError
_________________________ test_pie_center_radius[png] __________________________

    @image_comparison(['pie_center_radius.png'], style='mpl20')
    def test_pie_center_radius():
        # The slices will be ordered and plotted counter-clockwise.
        labels = 'Frogs', 'Hogs', 'Dogs', 'Logs'
        sizes = [15, 30, 45, 10]
        colors = ['yellowgreen', 'gold', 'lightskyblue', 'lightcoral']
        explode = (0, 0.1, 0, 0)  # only "explode" the 2nd slice (i.e. 'Hogs')
    
>       plt.pie(sizes, explode=explode, labels=labels, colors=colors,
                autopct='%1.1f%%', shadow=True, startangle=90,
                wedgeprops={'linewidth': 0}, center=(1, 2), radius=1.5)

lib/matplotlib/tests/test_axes.py:5573: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/matplotlib/pyplot.py:2717: in pie
    return gca().pie(
lib/matplotlib/__init__.py:1423: in inner
    return func(ax, *map(sanitize_sequence, args), **kwargs)
lib/matplotlib/axes/_axes.py:3268: in pie
    self.set(frame_on=False, xticks=[], yticks=[],
lib/matplotlib/artist.py:117: in <lambda>
    cls.set = lambda self, **kwargs: Artist.set(self, **kwargs)
lib/matplotlib/artist.py:1194: in set
    return self._internal_update(cbook.normalize_kwargs(kwargs, self))
lib/matplotlib/artist.py:1186: in _internal_update
    return self._update_props(
lib/matplotlib/artist.py:1162: in _update_props
    ret.append(func(v))
lib/matplotlib/axes/_base.py:73: in wrapper
    return get_method(self)(*args, **kwargs)
lib/matplotlib/axis.py:2033: in set_ticks
    result = self._set_tick_locations(ticks, minor=minor)
lib/matplotlib/axis.py:1977: in _set_tick_locations
    ticks = self.convert_units(ticks)
lib/matplotlib/axis.py:1663: in convert_units
    self.converter = munits.registry.get_converter(x)
lib/matplotlib/units.py:200: in get_converter
    first = cbook._safe_first_finite(x)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = []

    def _safe_first_finite(obj, *, skip_nonfinite=True):
        """
        Return the first non-None (and optionally finite) element in *obj*.
    
        This is a method for internal use.
    
        This is an type-independent way of obtaining the first non-None element,
        supporting both index access and the iterator protocol.
        The first non-None element will be obtained when skip_none is True.
        """
        def safe_isfinite(val):
            if val is None:
                return False
            try:
                return np.isfinite(val) if np.isscalar(val) else True
            except TypeError:
                # This is something that numpy can not make heads or tails
                # of, assume "finite"
                return True
        if skip_nonfinite is False:
            if isinstance(obj, collections.abc.Iterator):
                # needed to accept `array.flat` as input.
                # np.flatiter reports as an instance of collections.Iterator
                # but can still be indexed via [].
                # This has the side effect of re-setting the iterator, but
                # that is acceptable.
                try:
                    return obj[0]
                except TypeError:
                    pass
                raise RuntimeError("matplotlib does not support generators "
                                   "as input")
            return next(iter(obj))
        elif isinstance(obj, np.flatiter):
            # TODO do the finite filtering on this
            return obj[0]
        elif isinstance(obj, collections.abc.Iterator):
            raise RuntimeError("matplotlib does not "
                               "support generators as input")
        else:
            for val in obj:
                if safe_isfinite(val):
                    return val
>           raise ValueError('No finite values found in the input.')
E           ValueError: No finite values found in the input.

lib/matplotlib/cbook/__init__.py:1752: ValueError
__________________________ test_pie_linewidth_2[png] ___________________________

    @image_comparison(['pie_linewidth_2.png'], style='mpl20')
    def test_pie_linewidth_2():
        # The slices will be ordered and plotted counter-clockwise.
        labels = 'Frogs', 'Hogs', 'Dogs', 'Logs'
        sizes = [15, 30, 45, 10]
        colors = ['yellowgreen', 'gold', 'lightskyblue', 'lightcoral']
        explode = (0, 0.1, 0, 0)  # only "explode" the 2nd slice (i.e. 'Hogs')
    
>       plt.pie(sizes, explode=explode, labels=labels, colors=colors,
                autopct='%1.1f%%', shadow=True, startangle=90,
                wedgeprops={'linewidth': 2})

lib/matplotlib/tests/test_axes.py:5593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/matplotlib/pyplot.py:2717: in pie
    return gca().pie(
lib/matplotlib/__init__.py:1423: in inner
    return func(ax, *map(sanitize_sequence, args), **kwargs)
lib/matplotlib/axes/_axes.py:3268: in pie
    self.set(frame_on=False, xticks=[], yticks=[],
lib/matplotlib/artist.py:117: in <lambda>
    cls.set = lambda self, **kwargs: Artist.set(self, **kwargs)
lib/matplotlib/artist.py:1194: in set
    return self._internal_update(cbook.normalize_kwargs(kwargs, self))
lib/matplotlib/artist.py:1186: in _internal_update
    return self._update_props(
lib/matplotlib/artist.py:1162: in _update_props
    ret.append(func(v))
lib/matplotlib/axes/_base.py:73: in wrapper
    return get_method(self)(*args, **kwargs)
lib/matplotlib/axis.py:2033: in set_ticks
    result = self._set_tick_locations(ticks, minor=minor)
lib/matplotlib/axis.py:1977: in _set_tick_locations
    ticks = self.convert_units(ticks)
lib/matplotlib/axis.py:1663: in convert_units
    self.converter = munits.registry.get_converter(x)
lib/matplotlib/units.py:200: in get_converter
    first = cbook._safe_first_finite(x)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = []

    def _safe_first_finite(obj, *, skip_nonfinite=True):
        """
        Return the first non-None (and optionally finite) element in *obj*.
    
        This is a method for internal use.
    
        This is an type-independent way of obtaining the first non-None element,
        supporting both index access and the iterator protocol.
        The first non-None element will be obtained when skip_none is True.
        """
        def safe_isfinite(val):
            if val is None:
                return False
            try:
                return np.isfinite(val) if np.isscalar(val) else True
            except TypeError:
                # This is something that numpy can not make heads or tails
                # of, assume "finite"
                return True
        if skip_nonfinite is False:
            if isinstance(obj, collections.abc.Iterator):
                # needed to accept `array.flat` as input.
                # np.flatiter reports as an instance of collections.Iterator
                # but can still be indexed via [].
                # This has the side effect of re-setting the iterator, but
                # that is acceptable.
                try:
                    return obj[0]
                except TypeError:
                    pass
                raise RuntimeError("matplotlib does not support generators "
                                   "as input")
            return next(iter(obj))
        elif isinstance(obj, np.flatiter):
            # TODO do the finite filtering on this
            return obj[0]
        elif isinstance(obj, collections.abc.Iterator):
            raise RuntimeError("matplotlib does not "
                               "support generators as input")
        else:
            for val in obj:
                if safe_isfinite(val):
                    return val
>           raise ValueError('No finite values found in the input.')
E           ValueError: No finite values found in the input.

lib/matplotlib/cbook/__init__.py:1752: ValueError
____________________________ test_pie_ccw_true[png] ____________________________

    @image_comparison(['pie_ccw_true.png'], style='mpl20')
    def test_pie_ccw_true():
        # The slices will be ordered and plotted counter-clockwise.
        labels = 'Frogs', 'Hogs', 'Dogs', 'Logs'
        sizes = [15, 30, 45, 10]
        colors = ['yellowgreen', 'gold', 'lightskyblue', 'lightcoral']
        explode = (0, 0.1, 0, 0)  # only "explode" the 2nd slice (i.e. 'Hogs')
    
>       plt.pie(sizes, explode=explode, labels=labels, colors=colors,
                autopct='%1.1f%%', shadow=True, startangle=90,
                counterclock=True)

lib/matplotlib/tests/test_axes.py:5608: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/matplotlib/pyplot.py:2717: in pie
    return gca().pie(
lib/matplotlib/__init__.py:1423: in inner
    return func(ax, *map(sanitize_sequence, args), **kwargs)
lib/matplotlib/axes/_axes.py:3268: in pie
    self.set(frame_on=False, xticks=[], yticks=[],
lib/matplotlib/artist.py:117: in <lambda>
    cls.set = lambda self, **kwargs: Artist.set(self, **kwargs)
lib/matplotlib/artist.py:1194: in set
    return self._internal_update(cbook.normalize_kwargs(kwargs, self))
lib/matplotlib/artist.py:1186: in _internal_update
    return self._update_props(
lib/matplotlib/artist.py:1162: in _update_props
    ret.append(func(v))
lib/matplotlib/axes/_base.py:73: in wrapper
    return get_method(self)(*args, **kwargs)
lib/matplotlib/axis.py:2033: in set_ticks
    result = self._set_tick_locations(ticks, minor=minor)
lib/matplotlib/axis.py:1977: in _set_tick_locations
    ticks = self.convert_units(ticks)
lib/matplotlib/axis.py:1663: in convert_units
    self.converter = munits.registry.get_converter(x)
lib/matplotlib/units.py:200: in get_converter
    first = cbook._safe_first_finite(x)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = []

    def _safe_first_finite(obj, *, skip_nonfinite=True):
        """
        Return the first non-None (and optionally finite) element in *obj*.
    
        This is a method for internal use.
    
        This is an type-independent way of obtaining the first non-None element,
        supporting both index access and the iterator protocol.
        The first non-None element will be obtained when skip_none is True.
        """
        def safe_isfinite(val):
            if val is None:
                return False
            try:
                return np.isfinite(val) if np.isscalar(val) else True
            except TypeError:
                # This is something that numpy can not make heads or tails
                # of, assume "finite"
                return True
        if skip_nonfinite is False:
            if isinstance(obj, collections.abc.Iterator):
                # needed to accept `array.flat` as input.
                # np.flatiter reports as an instance of collections.Iterator
                # but can still be indexed via [].
                # This has the side effect of re-setting the iterator, but
                # that is acceptable.
                try:
                    return obj[0]
                except TypeError:
                    pass
                raise RuntimeError("matplotlib does not support generators "
                                   "as input")
            return next(iter(obj))
        elif isinstance(obj, np.flatiter):
            # TODO do the finite filtering on this
            return obj[0]
        elif isinstance(obj, collections.abc.Iterator):
            raise RuntimeError("matplotlib does not "
                               "support generators as input")
        else:
            for val in obj:
                if safe_isfinite(val):
                    return val
>           raise ValueError('No finite values found in the input.')
E           ValueError: No finite values found in the input.

lib/matplotlib/cbook/__init__.py:1752: ValueError
_______________________ test_pie_rotatelabels_true[png] ________________________

    @image_comparison(['pie_rotatelabels_true.png'], style='mpl20')
    def test_pie_rotatelabels_true():
        # The slices will be ordered and plotted counter-clockwise.
        labels = 'Hogwarts', 'Frogs', 'Dogs', 'Logs'
        sizes = [15, 30, 45, 10]
        colors = ['yellowgreen', 'gold', 'lightskyblue', 'lightcoral']
        explode = (0, 0.1, 0, 0)  # only "explode" the 2nd slice (i.e. 'Hogs')
    
>       plt.pie(sizes, explode=explode, labels=labels, colors=colors,
                autopct='%1.1f%%', shadow=True, startangle=90,
                rotatelabels=True)

lib/matplotlib/tests/test_axes.py:5650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/matplotlib/pyplot.py:2717: in pie
    return gca().pie(
lib/matplotlib/__init__.py:1423: in inner
    return func(ax, *map(sanitize_sequence, args), **kwargs)
lib/matplotlib/axes/_axes.py:3268: in pie
    self.set(frame_on=False, xticks=[], yticks=[],
lib/matplotlib/artist.py:117: in <lambda>
    cls.set = lambda self, **kwargs: Artist.set(self, **kwargs)
lib/matplotlib/artist.py:1194: in set
    return self._internal_update(cbook.normalize_kwargs(kwargs, self))
lib/matplotlib/artist.py:1186: in _internal_update
    return self._update_props(
lib/matplotlib/artist.py:1162: in _update_props
    ret.append(func(v))
lib/matplotlib/axes/_base.py:73: in wrapper
    return get_method(self)(*args, **kwargs)
lib/matplotlib/axis.py:2033: in set_ticks
    result = self._set_tick_locations(ticks, minor=minor)
lib/matplotlib/axis.py:1977: in _set_tick_locations
    ticks = self.convert_units(ticks)
lib/matplotlib/axis.py:1663: in convert_units
    self.converter = munits.registry.get_converter(x)
lib/matplotlib/units.py:200: in get_converter
    first = cbook._safe_first_finite(x)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = []

    def _safe_first_finite(obj, *, skip_nonfinite=True):
        """
        Return the first non-None (and optionally finite) element in *obj*.
    
        This is a method for internal use.
    
        This is an type-independent way of obtaining the first non-None element,
        supporting both index access and the iterator protocol.
        The first non-None element will be obtained when skip_none is True.
        """
        def safe_isfinite(val):
            if val is None:
                return False
            try:
                return np.isfinite(val) if np.isscalar(val) else True
            except TypeError:
                # This is something that numpy can not make heads or tails
                # of, assume "finite"
                return True
        if skip_nonfinite is False:
            if isinstance(obj, collections.abc.Iterator):
                # needed to accept `array.flat` as input.
                # np.flatiter reports as an instance of collections.Iterator
                # but can still be indexed via [].
                # This has the side effect of re-setting the iterator, but
                # that is acceptable.
                try:
                    return obj[0]
                except TypeError:
                    pass
                raise RuntimeError("matplotlib does not support generators "
                                   "as input")
            return next(iter(obj))
        elif isinstance(obj, np.flatiter):
            # TODO do the finite filtering on this
            return obj[0]
        elif isinstance(obj, collections.abc.Iterator):
            raise RuntimeError("matplotlib does not "
                               "support generators as input")
        else:
            for val in obj:
                if safe_isfinite(val):
                    return val
>           raise ValueError('No finite values found in the input.')
E           ValueError: No finite values found in the input.

lib/matplotlib/cbook/__init__.py:1752: ValueError
_______________________ test_pie_nolabel_but_legend[png] _______________________

    @image_comparison(['pie_no_label.png'])
    def test_pie_nolabel_but_legend():
        labels = 'Frogs', 'Hogs', 'Dogs', 'Logs'
        sizes = [15, 30, 45, 10]
        colors = ['yellowgreen', 'gold', 'lightskyblue', 'lightcoral']
        explode = (0, 0.1, 0, 0)  # only "explode" the 2nd slice (i.e. 'Hogs')
>       plt.pie(sizes, explode=explode, labels=labels, colors=colors,
                autopct='%1.1f%%', shadow=True, startangle=90, labeldistance=None,
                rotatelabels=True)

lib/matplotlib/tests/test_axes.py:5663: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/matplotlib/pyplot.py:2717: in pie
    return gca().pie(
lib/matplotlib/__init__.py:1423: in inner
    return func(ax, *map(sanitize_sequence, args), **kwargs)
lib/matplotlib/axes/_axes.py:3268: in pie
    self.set(frame_on=False, xticks=[], yticks=[],
lib/matplotlib/artist.py:117: in <lambda>
    cls.set = lambda self, **kwargs: Artist.set(self, **kwargs)
lib/matplotlib/artist.py:1194: in set
    return self._internal_update(cbook.normalize_kwargs(kwargs, self))
lib/matplotlib/artist.py:1186: in _internal_update
    return self._update_props(
lib/matplotlib/artist.py:1162: in _update_props
    ret.append(func(v))
lib/matplotlib/axes/_base.py:73: in wrapper
    return get_method(self)(*args, **kwargs)
lib/matplotlib/axis.py:2033: in set_ticks
    result = self._set_tick_locations(ticks, minor=minor)
lib/matplotlib/axis.py:1977: in _set_tick_locations
    ticks = self.convert_units(ticks)
lib/matplotlib/axis.py:1663: in convert_units
    self.converter = munits.registry.get_converter(x)
lib/matplotlib/units.py:200: in get_converter
    first = cbook._safe_first_finite(x)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = []

    def _safe_first_finite(obj, *, skip_nonfinite=True):
        """
        Return the first non-None (and optionally finite) element in *obj*.
    
        This is a method for internal use.
    
        This is an type-independent way of obtaining the first non-None element,
        supporting both index access and the iterator protocol.
        The first non-None element will be obtained when skip_none is True.
        """
        def safe_isfinite(val):
            if val is None:
                return False
            try:
                return np.isfinite(val) if np.isscalar(val) else True
            except TypeError:
                # This is something that numpy can not make heads or tails
                # of, assume "finite"
                return True
        if skip_nonfinite is False:
            if isinstance(obj, collections.abc.Iterator):
                # needed to accept `array.flat` as input.
                # np.flatiter reports as an instance of collections.Iterator
                # but can still be indexed via [].
                # This has the side effect of re-setting the iterator, but
                # that is acceptable.
                try:
                    return obj[0]
                except TypeError:
                    pass
                raise RuntimeError("matplotlib does not support generators "
                                   "as input")
            return next(iter(obj))
        elif isinstance(obj, np.flatiter):
            # TODO do the finite filtering on this
            return obj[0]
        elif isinstance(obj, collections.abc.Iterator):
            raise RuntimeError("matplotlib does not "
                               "support generators as input")
        else:
            for val in obj:
                if safe_isfinite(val):
                    return val
>           raise ValueError('No finite values found in the input.')
E           ValueError: No finite values found in the input.

lib/matplotlib/cbook/__init__.py:1752: ValueError
______________________________ test_pie_textprops ______________________________

    def test_pie_textprops():
        data = [23, 34, 45]
        labels = ["Long name 1", "Long name 2", "Long name 3"]
    
        textprops = dict(horizontalalignment="center",
                         verticalalignment="top",
                         rotation=90,
                         rotation_mode="anchor",
                         size=12, color="red")
    
>       _, texts, autopct = plt.gca().pie(data, labels=labels, autopct='%.2f',
                                          textprops=textprops)

lib/matplotlib/tests/test_axes.py:5681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/matplotlib/__init__.py:1423: in inner
    return func(ax, *map(sanitize_sequence, args), **kwargs)
lib/matplotlib/axes/_axes.py:3268: in pie
    self.set(frame_on=False, xticks=[], yticks=[],
lib/matplotlib/artist.py:117: in <lambda>
    cls.set = lambda self, **kwargs: Artist.set(self, **kwargs)
lib/matplotlib/artist.py:1194: in set
    return self._internal_update(cbook.normalize_kwargs(kwargs, self))
lib/matplotlib/artist.py:1186: in _internal_update
    return self._update_props(
lib/matplotlib/artist.py:1162: in _update_props
    ret.append(func(v))
lib/matplotlib/axes/_base.py:73: in wrapper
    return get_method(self)(*args, **kwargs)
lib/matplotlib/axis.py:2033: in set_ticks
    result = self._set_tick_locations(ticks, minor=minor)
lib/matplotlib/axis.py:1977: in _set_tick_locations
    ticks = self.convert_units(ticks)
lib/matplotlib/axis.py:1663: in convert_units
    self.converter = munits.registry.get_converter(x)
lib/matplotlib/units.py:200: in get_converter
    first = cbook._safe_first_finite(x)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = []

    def _safe_first_finite(obj, *, skip_nonfinite=True):
        """
        Return the first non-None (and optionally finite) element in *obj*.
    
        This is a method for internal use.
    
        This is an type-independent way of obtaining the first non-None element,
        supporting both index access and the iterator protocol.
        The first non-None element will be obtained when skip_none is True.
        """
        def safe_isfinite(val):
            if val is None:
                return False
            try:
                return np.isfinite(val) if np.isscalar(val) else True
            except TypeError:
                # This is something that numpy can not make heads or tails
                # of, assume "finite"
                return True
        if skip_nonfinite is False:
            if isinstance(obj, collections.abc.Iterator):
                # needed to accept `array.flat` as input.
                # np.flatiter reports as an instance of collections.Iterator
                # but can still be indexed via [].
                # This has the side effect of re-setting the iterator, but
                # that is acceptable.
                try:
                    return obj[0]
                except TypeError:
                    pass
                raise RuntimeError("matplotlib does not support generators "
                                   "as input")
            return next(iter(obj))
        elif isinstance(obj, np.flatiter):
            # TODO do the finite filtering on this
            return obj[0]
        elif isinstance(obj, collections.abc.Iterator):
            raise RuntimeError("matplotlib does not "
                               "support generators as input")
        else:
            for val in obj:
                if safe_isfinite(val):
                    return val
>           raise ValueError('No finite values found in the input.')
E           ValueError: No finite values found in the input.

lib/matplotlib/cbook/__init__.py:1752: ValueError
___________________________ test_normalize_kwarg_pie ___________________________

    def test_normalize_kwarg_pie():
        fig, ax = plt.subplots()
        x = [0.3, 0.3, 0.1]
>       t1 = ax.pie(x=x, normalize=True)

lib/matplotlib/tests/test_axes.py:5703: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/matplotlib/__init__.py:1423: in inner
    return func(ax, *map(sanitize_sequence, args), **kwargs)
lib/matplotlib/axes/_axes.py:3268: in pie
    self.set(frame_on=False, xticks=[], yticks=[],
lib/matplotlib/artist.py:117: in <lambda>
    cls.set = lambda self, **kwargs: Artist.set(self, **kwargs)
lib/matplotlib/artist.py:1194: in set
    return self._internal_update(cbook.normalize_kwargs(kwargs, self))
lib/matplotlib/artist.py:1186: in _internal_update
    return self._update_props(
lib/matplotlib/artist.py:1162: in _update_props
    ret.append(func(v))
lib/matplotlib/axes/_base.py:73: in wrapper
    return get_method(self)(*args, **kwargs)
lib/matplotlib/axis.py:2033: in set_ticks
    result = self._set_tick_locations(ticks, minor=minor)
lib/matplotlib/axis.py:1977: in _set_tick_locations
    ticks = self.convert_units(ticks)
lib/matplotlib/axis.py:1663: in convert_units
    self.converter = munits.registry.get_converter(x)
lib/matplotlib/units.py:200: in get_converter
    first = cbook._safe_first_finite(x)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = []

    def _safe_first_finite(obj, *, skip_nonfinite=True):
        """
        Return the first non-None (and optionally finite) element in *obj*.
    
        This is a method for internal use.
    
        This is an type-independent way of obtaining the first non-None element,
        supporting both index access and the iterator protocol.
        The first non-None element will be obtained when skip_none is True.
        """
        def safe_isfinite(val):
            if val is None:
                return False
            try:
                return np.isfinite(val) if np.isscalar(val) else True
            except TypeError:
                # This is something that numpy can not make heads or tails
                # of, assume "finite"
                return True
        if skip_nonfinite is False:
            if isinstance(obj, collections.abc.Iterator):
                # needed to accept `array.flat` as input.
                # np.flatiter reports as an instance of collections.Iterator
                # but can still be indexed via [].
                # This has the side effect of re-setting the iterator, but
                # that is acceptable.
                try:
                    return obj[0]
                except TypeError:
                    pass
                raise RuntimeError("matplotlib does not support generators "
                                   "as input")
            return next(iter(obj))
        elif isinstance(obj, np.flatiter):
            # TODO do the finite filtering on this
            return obj[0]
        elif isinstance(obj, collections.abc.Iterator):
            raise RuntimeError("matplotlib does not "
                               "support generators as input")
        else:
            for val in obj:
                if safe_isfinite(val):
                    return val
>           raise ValueError('No finite values found in the input.')
E           ValueError: No finite values found in the input.

lib/matplotlib/cbook/__init__.py:1752: ValueError
___________________________ test_scatter_empty_data ____________________________

    def test_scatter_empty_data():
        # making sure this does not raise an exception
>       plt.scatter([], [])

lib/matplotlib/tests/test_axes.py:7081: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/matplotlib/pyplot.py:2780: in scatter
    __ret = gca().scatter(
lib/matplotlib/__init__.py:1423: in inner
    return func(ax, *map(sanitize_sequence, args), **kwargs)
lib/matplotlib/axes/_axes.py:4540: in scatter
    x, y = self._process_unit_info([("x", x), ("y", y)], kwargs)
lib/matplotlib/axes/_base.py:2585: in _process_unit_info
    axis.update_units(data)
lib/matplotlib/axis.py:1605: in update_units
    converter = munits.registry.get_converter(data)
lib/matplotlib/units.py:200: in get_converter
    first = cbook._safe_first_finite(x)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = []

    def _safe_first_finite(obj, *, skip_nonfinite=True):
        """
        Return the first non-None (and optionally finite) element in *obj*.
    
        This is a method for internal use.
    
        This is an type-independent way of obtaining the first non-None element,
        supporting both index access and the iterator protocol.
        The first non-None element will be obtained when skip_none is True.
        """
        def safe_isfinite(val):
            if val is None:
                return False
            try:
                return np.isfinite(val) if np.isscalar(val) else True
            except TypeError:
                # This is something that numpy can not make heads or tails
                # of, assume "finite"
                return True
        if skip_nonfinite is False:
            if isinstance(obj, collections.abc.Iterator):
                # needed to accept `array.flat` as input.
                # np.flatiter reports as an instance of collections.Iterator
                # but can still be indexed via [].
                # This has the side effect of re-setting the iterator, but
                # that is acceptable.
                try:
                    return obj[0]
                except TypeError:
                    pass
                raise RuntimeError("matplotlib does not support generators "
                                   "as input")
            return next(iter(obj))
        elif isinstance(obj, np.flatiter):
            # TODO do the finite filtering on this
            return obj[0]
        elif isinstance(obj, collections.abc.Iterator):
            raise RuntimeError("matplotlib does not "
                               "support generators as input")
        else:
            for val in obj:
                if safe_isfinite(val):
                    return val
>           raise ValueError('No finite values found in the input.')
E           ValueError: No finite values found in the input.

lib/matplotlib/cbook/__init__.py:1752: ValueError
____________________________ test_bar_all_nan[png] _____________________________

ext = 'png', request = <FixtureRequest for <Function test_bar_all_nan[png]>>
args = (), kwargs = {}, file_name = 'test_bar_all_nan[png]'
fig_test = <Figure size 640x480 with 1 Axes>
fig_ref = <Figure size 640x480 with 1 Axes>, figs = []

    @pytest.mark.parametrize("ext", extensions)
    def wrapper(*args, ext, request, **kwargs):
        if 'ext' in old_sig.parameters:
            kwargs['ext'] = ext
        if 'request' in old_sig.parameters:
            kwargs['request'] = request
    
        file_name = "".join(c for c in request.node.name
                            if c in ALLOWED_CHARS)
        try:
            fig_test = plt.figure("test")
            fig_ref = plt.figure("reference")
            with _collect_new_figures() as figs:
>               func(*args, fig_test=fig_test, fig_ref=fig_ref, **kwargs)

lib/matplotlib/testing/decorators.py:472: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/matplotlib/tests/test_axes.py:8206: in test_bar_all_nan
    ax_test.bar([np.nan], [np.nan])
lib/matplotlib/__init__.py:1423: in inner
    return func(ax, *map(sanitize_sequence, args), **kwargs)
lib/matplotlib/axes/_axes.py:2358: in bar
    self._process_unit_info(
lib/matplotlib/axes/_base.py:2585: in _process_unit_info
    axis.update_units(data)
lib/matplotlib/axis.py:1605: in update_units
    converter = munits.registry.get_converter(data)
lib/matplotlib/units.py:200: in get_converter
    first = cbook._safe_first_finite(x)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = [nan]

    def _safe_first_finite(obj, *, skip_nonfinite=True):
        """
        Return the first non-None (and optionally finite) element in *obj*.
    
        This is a method for internal use.
    
        This is an type-independent way of obtaining the first non-None element,
        supporting both index access and the iterator protocol.
        The first non-None element will be obtained when skip_none is True.
        """
        def safe_isfinite(val):
            if val is None:
                return False
            try:
                return np.isfinite(val) if np.isscalar(val) else True
            except TypeError:
                # This is something that numpy can not make heads or tails
                # of, assume "finite"
                return True
        if skip_nonfinite is False:
            if isinstance(obj, collections.abc.Iterator):
                # needed to accept `array.flat` as input.
                # np.flatiter reports as an instance of collections.Iterator
                # but can still be indexed via [].
                # This has the side effect of re-setting the iterator, but
                # that is acceptable.
                try:
                    return obj[0]
                except TypeError:
                    pass
                raise RuntimeError("matplotlib does not support generators "
                                   "as input")
            return next(iter(obj))
        elif isinstance(obj, np.flatiter):
            # TODO do the finite filtering on this
            return obj[0]
        elif isinstance(obj, collections.abc.Iterator):
            raise RuntimeError("matplotlib does not "
                               "support generators as input")
        else:
            for val in obj:
                if safe_isfinite(val):
                    return val
>           raise ValueError('No finite values found in the input.')
E           ValueError: No finite values found in the input.

lib/matplotlib/cbook/__init__.py:1752: ValueError
==================================== PASSES ====================================
___________________ TestScatter.test_scatter_c[c_case9-None] ___________________
------------------------------ Captured log call -------------------------------
WARNING  matplotlib.axes._axes:_axes.py:4390 *c* argument looks like a single numeric RGB or RGBA sequence, which should be avoided as value-mapping will have precedence in case its length matches with *x* & *y*.  Please use the *color* keyword-argument or provide a 2D array with a single row if you intend to specify the same RGB or RGBA value for all points.
__________________________ test_color_length_mismatch __________________________
------------------------------ Captured log call -------------------------------
WARNING  matplotlib.axes._axes:_axes.py:4390 *c* argument looks like a single numeric RGB or RGBA sequence, which should be avoided as value-mapping will have precedence in case its length matches with *x* & *y*.  Please use the *color* keyword-argument or provide a 2D array with a single row if you intend to specify the same RGB or RGBA value for all points.
____________________________ test_2dcolor_plot[pdf] ____________________________
------------------------------ Captured log call -------------------------------
WARNING  matplotlib.axes._axes:_axes.py:4390 *c* argument looks like a single numeric RGB or RGBA sequence, which should be avoided as value-mapping will have precedence in case its length matches with *x* & *y*.  Please use the *color* keyword-argument or provide a 2D array with a single row if you intend to specify the same RGB or RGBA value for all points.
=========================== short test summary info ============================
PASSED lib/matplotlib/tests/test_axes.py::test_invisible_axes[png]
PASSED lib/matplotlib/tests/test_axes.py::test_get_labels
PASSED lib/matplotlib/tests/test_axes.py::test_repr
PASSED lib/matplotlib/tests/test_axes.py::test_label_shift
PASSED lib/matplotlib/tests/test_axes.py::test_acorr[png]
PASSED lib/matplotlib/tests/test_axes.py::test_spy[png]
PASSED lib/matplotlib/tests/test_axes.py::test_spy_invalid_kwargs
PASSED lib/matplotlib/tests/test_axes.py::test_matshow[png]
PASSED lib/matplotlib/tests/test_axes.py::test_formatter_ticker[png]
PASSED lib/matplotlib/tests/test_axes.py::test_formatter_ticker[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_formatter_ticker[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_funcformatter_auto_formatter
PASSED lib/matplotlib/tests/test_axes.py::test_strmethodformatter_auto_formatter
PASSED lib/matplotlib/tests/test_axes.py::test_twin_axis_locators_formatters[png]
PASSED lib/matplotlib/tests/test_axes.py::test_twin_axis_locators_formatters[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_twin_axis_locators_formatters[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_twinx_cla
PASSED lib/matplotlib/tests/test_axes.py::test_twin_logscale[png-x]
PASSED lib/matplotlib/tests/test_axes.py::test_twin_logscale[png-y]
PASSED lib/matplotlib/tests/test_axes.py::test_twinx_axis_scales[png]
PASSED lib/matplotlib/tests/test_axes.py::test_twin_inherit_autoscale_setting
PASSED lib/matplotlib/tests/test_axes.py::test_inverted_cla
PASSED lib/matplotlib/tests/test_axes.py::test_subclass_clear_cla
PASSED lib/matplotlib/tests/test_axes.py::test_cla_not_redefined_internally
PASSED lib/matplotlib/tests/test_axes.py::test_minorticks_on_rcParams_both[png]
PASSED lib/matplotlib/tests/test_axes.py::test_autoscale_tiny_range[png]
PASSED lib/matplotlib/tests/test_axes.py::test_autoscale_tiny_range[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_autoscale_tiny_range[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_autoscale_tight
PASSED lib/matplotlib/tests/test_axes.py::test_autoscale_log_shared
PASSED lib/matplotlib/tests/test_axes.py::test_use_sticky_edges
PASSED lib/matplotlib/tests/test_axes.py::test_sticky_shared_axes[png]
PASSED lib/matplotlib/tests/test_axes.py::test_basic_annotate[png]
PASSED lib/matplotlib/tests/test_axes.py::test_basic_annotate[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_basic_annotate[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_arrow_simple[png]
PASSED lib/matplotlib/tests/test_axes.py::test_arrow_empty
PASSED lib/matplotlib/tests/test_axes.py::test_arrow_in_view
PASSED lib/matplotlib/tests/test_axes.py::test_annotate_default_arrow
PASSED lib/matplotlib/tests/test_axes.py::test_annotate_signature
PASSED lib/matplotlib/tests/test_axes.py::test_fill_units[png]
PASSED lib/matplotlib/tests/test_axes.py::test_plot_format_kwarg_redundant
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_dashes[png]
PASSED lib/matplotlib/tests/test_axes.py::test_single_point[png]
PASSED lib/matplotlib/tests/test_axes.py::test_single_point[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_single_point[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_single_date[png]
PASSED lib/matplotlib/tests/test_axes.py::test_shaped_data[png]
PASSED lib/matplotlib/tests/test_axes.py::test_structured_data
PASSED lib/matplotlib/tests/test_axes.py::test_aitoff_proj[png]
PASSED lib/matplotlib/tests/test_axes.py::test_axvspan_epoch[png]
PASSED lib/matplotlib/tests/test_axes.py::test_axvspan_epoch[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_axvspan_epoch[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_axhspan_epoch[png]
PASSED lib/matplotlib/tests/test_axes.py::test_axhspan_epoch[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_axhspan_epoch[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_hexbin_extent[png]
PASSED lib/matplotlib/tests/test_axes.py::test_hexbin_pickable
PASSED lib/matplotlib/tests/test_axes.py::test_hexbin_linear[png]
PASSED lib/matplotlib/tests/test_axes.py::test_hexbin_log_clim
PASSED lib/matplotlib/tests/test_axes.py::test_inverted_limits
PASSED lib/matplotlib/tests/test_axes.py::test_nonfinite_limits[png]
PASSED lib/matplotlib/tests/test_axes.py::test_nonfinite_limits[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_nonfinite_limits[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_limits_empty_data[png-plot]
PASSED lib/matplotlib/tests/test_axes.py::test_imshow[png]
PASSED lib/matplotlib/tests/test_axes.py::test_imshow[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_imshow[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_imshow_clip[png]
PASSED lib/matplotlib/tests/test_axes.py::test_imshow_clip[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_imshow_clip[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_imshow_norm_vminvmax
PASSED lib/matplotlib/tests/test_axes.py::test_polycollection_joinstyle[png]
PASSED lib/matplotlib/tests/test_axes.py::test_polycollection_joinstyle[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_polycollection_joinstyle[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_fill_between_input[2d_x_input]
PASSED lib/matplotlib/tests/test_axes.py::test_fill_between_input[2d_y1_input]
PASSED lib/matplotlib/tests/test_axes.py::test_fill_between_input[2d_y2_input]
PASSED lib/matplotlib/tests/test_axes.py::test_fill_betweenx_input[2d_y_input]
PASSED lib/matplotlib/tests/test_axes.py::test_fill_betweenx_input[2d_x1_input]
PASSED lib/matplotlib/tests/test_axes.py::test_fill_betweenx_input[2d_x2_input]
PASSED lib/matplotlib/tests/test_axes.py::test_fill_between_interpolate[png]
PASSED lib/matplotlib/tests/test_axes.py::test_fill_between_interpolate[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_fill_between_interpolate[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_fill_between_interpolate_decreasing[png]
PASSED lib/matplotlib/tests/test_axes.py::test_fill_between_interpolate_decreasing[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_fill_between_interpolate_decreasing[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_fill_between_interpolate_nan[png]
PASSED lib/matplotlib/tests/test_axes.py::test_fill_between_interpolate_nan[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_fill_between_interpolate_nan[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_symlog[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_symlog2[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_pcolorargs_5205
PASSED lib/matplotlib/tests/test_axes.py::test_pcolormesh[png]
PASSED lib/matplotlib/tests/test_axes.py::test_pcolormesh[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_pcolormesh[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_pcolormesh_alpha[png]
PASSED lib/matplotlib/tests/test_axes.py::test_pcolormesh_alpha[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_pcolormesh_datetime_axis[png]
PASSED lib/matplotlib/tests/test_axes.py::test_pcolor_datetime_axis[png]
PASSED lib/matplotlib/tests/test_axes.py::test_pcolorargs
PASSED lib/matplotlib/tests/test_axes.py::test_pcolornearest[png]
PASSED lib/matplotlib/tests/test_axes.py::test_pcolornearestunits[png]
PASSED lib/matplotlib/tests/test_axes.py::test_pcolorflaterror
PASSED lib/matplotlib/tests/test_axes.py::test_pcolorauto[png-False]
PASSED lib/matplotlib/tests/test_axes.py::test_pcolorauto[png-True]
PASSED lib/matplotlib/tests/test_axes.py::test_canonical[png]
PASSED lib/matplotlib/tests/test_axes.py::test_canonical[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_canonical[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_arc_angles[png]
PASSED lib/matplotlib/tests/test_axes.py::test_arc_ellipse[png]
PASSED lib/matplotlib/tests/test_axes.py::test_arc_ellipse[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_arc_ellipse[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_marker_as_markerstyle
PASSED lib/matplotlib/tests/test_axes.py::test_markevery[png]
PASSED lib/matplotlib/tests/test_axes.py::test_markevery[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_markevery[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_markevery_line[png]
PASSED lib/matplotlib/tests/test_axes.py::test_markevery_line[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_markevery_line[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_markevery_linear_scales[png]
PASSED lib/matplotlib/tests/test_axes.py::test_markevery_linear_scales[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_markevery_linear_scales[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_markevery_linear_scales_zoomed[png]
PASSED lib/matplotlib/tests/test_axes.py::test_markevery_linear_scales_zoomed[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_markevery_linear_scales_zoomed[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_markevery_log_scales[png]
PASSED lib/matplotlib/tests/test_axes.py::test_markevery_log_scales[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_markevery_log_scales[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_markevery_polar[png]
PASSED lib/matplotlib/tests/test_axes.py::test_markevery_polar[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_markevery_polar[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_markevery_linear_scales_nans[png]
PASSED lib/matplotlib/tests/test_axes.py::test_markevery_linear_scales_nans[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_markevery_linear_scales_nans[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_marker_edges[png]
PASSED lib/matplotlib/tests/test_axes.py::test_marker_edges[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_marker_edges[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_bar_tick_label_single[png]
PASSED lib/matplotlib/tests/test_axes.py::test_nan_bar_values
PASSED lib/matplotlib/tests/test_axes.py::test_bar_tick_label_multiple[png]
PASSED lib/matplotlib/tests/test_axes.py::test_bar_tick_label_multiple_old_alignment[png]
PASSED lib/matplotlib/tests/test_axes.py::test_bar_decimal_center[png]
PASSED lib/matplotlib/tests/test_axes.py::test_barh_decimal_center[png]
PASSED lib/matplotlib/tests/test_axes.py::test_bar_decimal_width[png]
PASSED lib/matplotlib/tests/test_axes.py::test_barh_decimal_height[png]
PASSED lib/matplotlib/tests/test_axes.py::test_bar_color_none_alpha
PASSED lib/matplotlib/tests/test_axes.py::test_bar_edgecolor_none_alpha
PASSED lib/matplotlib/tests/test_axes.py::test_barh_tick_label[png]
PASSED lib/matplotlib/tests/test_axes.py::test_bar_timedelta
PASSED lib/matplotlib/tests/test_axes.py::test_boxplot_dates_pandas
PASSED lib/matplotlib/tests/test_axes.py::test_boxplot_capwidths
PASSED lib/matplotlib/tests/test_axes.py::test_pcolor_regression
PASSED lib/matplotlib/tests/test_axes.py::test_bar_pandas
PASSED lib/matplotlib/tests/test_axes.py::test_bar_pandas_indexed
PASSED lib/matplotlib/tests/test_axes.py::test_bar_hatches[png]
PASSED lib/matplotlib/tests/test_axes.py::test_bar_hatches[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_bar_hatches[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_bar_labels[x-1-x-expected_labels0-x]
PASSED lib/matplotlib/tests/test_axes.py::test_bar_labels[x1-width1-label1-expected_labels1-_nolegend_]
PASSED lib/matplotlib/tests/test_axes.py::test_bar_labels[x2-width2-label2-expected_labels2-_nolegend_]
PASSED lib/matplotlib/tests/test_axes.py::test_bar_labels[x3-width3-bars-expected_labels3-bars]
PASSED lib/matplotlib/tests/test_axes.py::test_bar_labels_length
PASSED lib/matplotlib/tests/test_axes.py::test_pandas_minimal_plot
PASSED lib/matplotlib/tests/test_axes.py::test_hist_log[png]
PASSED lib/matplotlib/tests/test_axes.py::test_hist_log[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_hist_log[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_hist_log_2[png]
PASSED lib/matplotlib/tests/test_axes.py::test_hist_log_barstacked
PASSED lib/matplotlib/tests/test_axes.py::test_hist_float16
PASSED lib/matplotlib/tests/test_axes.py::test_hist_step_filled[png]
PASSED lib/matplotlib/tests/test_axes.py::test_hist_density[png]
PASSED lib/matplotlib/tests/test_axes.py::test_hist_unequal_bins_density
PASSED lib/matplotlib/tests/test_axes.py::test_hist_datetime_datasets
PASSED lib/matplotlib/tests/test_axes.py::test_hist_datetime_datasets_bins[date2num]
PASSED lib/matplotlib/tests/test_axes.py::test_hist_datetime_datasets_bins[datetime.datetime]
PASSED lib/matplotlib/tests/test_axes.py::test_hist_datetime_datasets_bins[np.datetime64]
PASSED lib/matplotlib/tests/test_axes.py::test_hist_with_empty_input[data1-1]
PASSED lib/matplotlib/tests/test_axes.py::test_hist_with_empty_input[data2-2]
PASSED lib/matplotlib/tests/test_axes.py::test_hist_zorder[bar-1]
PASSED lib/matplotlib/tests/test_axes.py::test_hist_zorder[step-2]
PASSED lib/matplotlib/tests/test_axes.py::test_hist_zorder[stepfilled-1]
PASSED lib/matplotlib/tests/test_axes.py::test_stairs[png]
PASSED lib/matplotlib/tests/test_axes.py::test_stairs_fill[png]
PASSED lib/matplotlib/tests/test_axes.py::test_stairs_update[png]
PASSED lib/matplotlib/tests/test_axes.py::test_stairs_baseline_0[png]
PASSED lib/matplotlib/tests/test_axes.py::test_stairs_invalid_nan
PASSED lib/matplotlib/tests/test_axes.py::test_stairs_invalid_mismatch
PASSED lib/matplotlib/tests/test_axes.py::test_stairs_invalid_update
PASSED lib/matplotlib/tests/test_axes.py::test_stairs_invalid_update2
PASSED lib/matplotlib/tests/test_axes.py::test_stairs_options[png]
PASSED lib/matplotlib/tests/test_axes.py::test_stairs_datetime[png]
PASSED lib/matplotlib/tests/test_axes.py::test_stairs_edge_handling[png]
PASSED lib/matplotlib/tests/test_axes.py::test_contour_hatching[png]
PASSED lib/matplotlib/tests/test_axes.py::test_contour_hatching[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_contour_hatching[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_hist2d[png]
PASSED lib/matplotlib/tests/test_axes.py::test_hist2d[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_hist2d[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_hist2d_transpose[png]
PASSED lib/matplotlib/tests/test_axes.py::test_hist2d_transpose[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_hist2d_transpose[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_hist2d_density
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_plot[png]
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_plot[pdf]
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_plot[svg]
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_marker[png]
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_2D[png]
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_decimal[png]
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_color
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_unfilled
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_unfillable
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_size_arg_size
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_edgecolor_RGB
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_invalid_color[png]
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_no_invalid_color[png]
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_norm_vminvmax
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_single_point[png]
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_different_shapes[png]
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_c[0.5-None]
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_c[c_case1-conversion]
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_c[red-None]
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_c[none-None]
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_c[None-None]
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_c[c_case5-None]
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_c[jaune-conversion]
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_c[c_case7-conversion]
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_c[c_case8-conversion]
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_c[c_case9-None]
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_c[c_case10-None]
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_c[c_case11-shape]
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_c[c_case12-None]
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_c[c_case13-None]
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_c[c_case14-conversion]
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_c[c_case15-None]
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_c[c_case16-shape]
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_c[c_case17-None]
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_c[c_case18-shape]
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_c[c_case19-None]
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_c[c_case20-shape]
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_c[c_case21-None]
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_c[c_case22-shape]
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_c[c_case23-None]
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_c[c_case24-shape]
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_c[c_case25-None]
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_c[c_case26-shape]
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_c[c_case27-conversion]
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_c[c_case28-conversion]
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_c[c_case29-conversion]
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_single_color_c[png]
PASSED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_linewidths
PASSED lib/matplotlib/tests/test_axes.py::test_parse_scatter_color_args[params0-expected_result0]
PASSED lib/matplotlib/tests/test_axes.py::test_parse_scatter_color_args[params1-expected_result1]
PASSED lib/matplotlib/tests/test_axes.py::test_parse_scatter_color_args[params2-expected_result2]
PASSED lib/matplotlib/tests/test_axes.py::test_parse_scatter_color_args[params3-expected_result3]
PASSED lib/matplotlib/tests/test_axes.py::test_parse_scatter_color_args[params4-expected_result4]
PASSED lib/matplotlib/tests/test_axes.py::test_parse_scatter_color_args_edgecolors[kwargs0-None]
PASSED lib/matplotlib/tests/test_axes.py::test_parse_scatter_color_args_edgecolors[kwargs1-None]
PASSED lib/matplotlib/tests/test_axes.py::test_parse_scatter_color_args_edgecolors[kwargs2-r]
PASSED lib/matplotlib/tests/test_axes.py::test_parse_scatter_color_args_edgecolors[kwargs3-expected_edgecolors3]
PASSED lib/matplotlib/tests/test_axes.py::test_parse_scatter_color_args_edgecolors[kwargs4-r]
PASSED lib/matplotlib/tests/test_axes.py::test_parse_scatter_color_args_edgecolors[kwargs5-face]
PASSED lib/matplotlib/tests/test_axes.py::test_parse_scatter_color_args_edgecolors[kwargs6-none]
PASSED lib/matplotlib/tests/test_axes.py::test_parse_scatter_color_args_edgecolors[kwargs7-r]
PASSED lib/matplotlib/tests/test_axes.py::test_parse_scatter_color_args_edgecolors[kwargs8-r]
PASSED lib/matplotlib/tests/test_axes.py::test_parse_scatter_color_args_edgecolors[kwargs9-r]
PASSED lib/matplotlib/tests/test_axes.py::test_parse_scatter_color_args_edgecolors[kwargs10-g]
PASSED lib/matplotlib/tests/test_axes.py::test_parse_scatter_color_args_error
PASSED lib/matplotlib/tests/test_axes.py::test_as_mpl_axes_api
PASSED lib/matplotlib/tests/test_axes.py::test_pyplot_axes
PASSED lib/matplotlib/tests/test_axes.py::test_log_scales
PASSED lib/matplotlib/tests/test_axes.py::test_log_scales_no_data
PASSED lib/matplotlib/tests/test_axes.py::test_log_scales_invalid
PASSED lib/matplotlib/tests/test_axes.py::test_stackplot[png]
PASSED lib/matplotlib/tests/test_axes.py::test_stackplot[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_stackplot[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_stackplot_baseline[png]
PASSED lib/matplotlib/tests/test_axes.py::test_stackplot_baseline[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_stackplot_baseline[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_bxp_baseline[png]
PASSED lib/matplotlib/tests/test_axes.py::test_bxp_rangewhis[png]
PASSED lib/matplotlib/tests/test_axes.py::test_bxp_percentilewhis[png]
PASSED lib/matplotlib/tests/test_axes.py::test_bxp_with_xlabels[png]
PASSED lib/matplotlib/tests/test_axes.py::test_bxp_horizontal[png]
PASSED lib/matplotlib/tests/test_axes.py::test_bxp_with_ylabels[png]
PASSED lib/matplotlib/tests/test_axes.py::test_bxp_patchartist[png]
PASSED lib/matplotlib/tests/test_axes.py::test_bxp_custompatchartist[png]
PASSED lib/matplotlib/tests/test_axes.py::test_bxp_customoutlier[png]
PASSED lib/matplotlib/tests/test_axes.py::test_bxp_showcustommean[png]
PASSED lib/matplotlib/tests/test_axes.py::test_bxp_custombox[png]
PASSED lib/matplotlib/tests/test_axes.py::test_bxp_custommedian[png]
PASSED lib/matplotlib/tests/test_axes.py::test_bxp_customcap[png]
PASSED lib/matplotlib/tests/test_axes.py::test_bxp_customwhisker[png]
PASSED lib/matplotlib/tests/test_axes.py::test_bxp_shownotches[png]
PASSED lib/matplotlib/tests/test_axes.py::test_bxp_nocaps[png]
PASSED lib/matplotlib/tests/test_axes.py::test_bxp_nobox[png]
PASSED lib/matplotlib/tests/test_axes.py::test_bxp_no_flier_stats[png]
PASSED lib/matplotlib/tests/test_axes.py::test_bxp_showmean[png]
PASSED lib/matplotlib/tests/test_axes.py::test_bxp_showmeanasline[png]
PASSED lib/matplotlib/tests/test_axes.py::test_bxp_scalarwidth[png]
PASSED lib/matplotlib/tests/test_axes.py::test_bxp_customwidths[png]
PASSED lib/matplotlib/tests/test_axes.py::test_bxp_custompositions[png]
PASSED lib/matplotlib/tests/test_axes.py::test_bxp_bad_widths
PASSED lib/matplotlib/tests/test_axes.py::test_bxp_bad_positions
PASSED lib/matplotlib/tests/test_axes.py::test_bxp_custom_capwidths[png]
PASSED lib/matplotlib/tests/test_axes.py::test_bxp_custom_capwidth[png]
PASSED lib/matplotlib/tests/test_axes.py::test_bxp_bad_capwidths
PASSED lib/matplotlib/tests/test_axes.py::test_boxplot[png]
PASSED lib/matplotlib/tests/test_axes.py::test_boxplot[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_boxplot[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_boxplot_custom_capwidths[png]
PASSED lib/matplotlib/tests/test_axes.py::test_boxplot_sym2[png]
PASSED lib/matplotlib/tests/test_axes.py::test_boxplot_sym[png]
PASSED lib/matplotlib/tests/test_axes.py::test_boxplot_autorange_whiskers[png]
PASSED lib/matplotlib/tests/test_axes.py::test_boxplot_rc_parameters[png]
PASSED lib/matplotlib/tests/test_axes.py::test_boxplot_rc_parameters[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_boxplot_rc_parameters[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_boxplot_with_CIarray[png]
PASSED lib/matplotlib/tests/test_axes.py::test_boxplot_no_weird_whisker[png]
PASSED lib/matplotlib/tests/test_axes.py::test_boxplot_bad_medians
PASSED lib/matplotlib/tests/test_axes.py::test_boxplot_bad_ci
PASSED lib/matplotlib/tests/test_axes.py::test_boxplot_zorder
PASSED lib/matplotlib/tests/test_axes.py::test_boxplot_marker_behavior
PASSED lib/matplotlib/tests/test_axes.py::test_boxplot_mod_artist_after_plotting[png]
PASSED lib/matplotlib/tests/test_axes.py::test_vert_violinplot_baseline[png]
PASSED lib/matplotlib/tests/test_axes.py::test_vert_violinplot_showmeans[png]
PASSED lib/matplotlib/tests/test_axes.py::test_vert_violinplot_showextrema[png]
PASSED lib/matplotlib/tests/test_axes.py::test_vert_violinplot_showmedians[png]
PASSED lib/matplotlib/tests/test_axes.py::test_vert_violinplot_showall[png]
PASSED lib/matplotlib/tests/test_axes.py::test_vert_violinplot_custompoints_10[png]
PASSED lib/matplotlib/tests/test_axes.py::test_vert_violinplot_custompoints_200[png]
PASSED lib/matplotlib/tests/test_axes.py::test_horiz_violinplot_baseline[png]
PASSED lib/matplotlib/tests/test_axes.py::test_horiz_violinplot_showmedians[png]
PASSED lib/matplotlib/tests/test_axes.py::test_horiz_violinplot_showmeans[png]
PASSED lib/matplotlib/tests/test_axes.py::test_horiz_violinplot_showextrema[png]
PASSED lib/matplotlib/tests/test_axes.py::test_horiz_violinplot_showall[png]
PASSED lib/matplotlib/tests/test_axes.py::test_horiz_violinplot_custompoints_10[png]
PASSED lib/matplotlib/tests/test_axes.py::test_horiz_violinplot_custompoints_200[png]
PASSED lib/matplotlib/tests/test_axes.py::test_violinplot_bad_positions
PASSED lib/matplotlib/tests/test_axes.py::test_violinplot_bad_widths
PASSED lib/matplotlib/tests/test_axes.py::test_violinplot_bad_quantiles
PASSED lib/matplotlib/tests/test_axes.py::test_violinplot_outofrange_quantiles
PASSED lib/matplotlib/tests/test_axes.py::test_violinplot_single_list_quantiles[png]
PASSED lib/matplotlib/tests/test_axes.py::test_violinplot_pandas_series[png]
PASSED lib/matplotlib/tests/test_axes.py::test_manage_xticks
PASSED lib/matplotlib/tests/test_axes.py::test_boxplot_not_single
PASSED lib/matplotlib/tests/test_axes.py::test_tick_space_size_0
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar[png]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_mixed_errorbar_polar_caps[png]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_colorcycle
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_cycle_ecolor[png]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_cycle_ecolor[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_cycle_ecolor[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_shape
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_limits[png]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_limits[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_limits[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_nonefmt
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_line_specific_kwargs
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_with_prop_cycle[png]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_every_invalid
PASSED lib/matplotlib/tests/test_axes.py::test_xerr_yerr_not_negative
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_every[png]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_every[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_every[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_linewidth_type[elinewidth0]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_linewidth_type[elinewidth1]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_linewidth_type[1]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_nan[png]
PASSED lib/matplotlib/tests/test_axes.py::test_hist_stacked_stepfilled[png]
PASSED lib/matplotlib/tests/test_axes.py::test_hist_stacked_stepfilled[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_hist_stacked_stepfilled[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_hist_offset[png]
PASSED lib/matplotlib/tests/test_axes.py::test_hist_offset[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_hist_offset[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_hist_step[png]
PASSED lib/matplotlib/tests/test_axes.py::test_hist_step_horiz[png]
PASSED lib/matplotlib/tests/test_axes.py::test_hist_stacked_weighted[png]
PASSED lib/matplotlib/tests/test_axes.py::test_hist_stacked_weighted[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_hist_stacked_weighted[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_stem[png-w/ line collection]
PASSED lib/matplotlib/tests/test_axes.py::test_stem[png-w/o line collection]
PASSED lib/matplotlib/tests/test_axes.py::test_stem_args
PASSED lib/matplotlib/tests/test_axes.py::test_stem_markerfmt
PASSED lib/matplotlib/tests/test_axes.py::test_stem_dates
PASSED lib/matplotlib/tests/test_axes.py::test_stem_orientation[png-w/ line collection]
PASSED lib/matplotlib/tests/test_axes.py::test_stem_orientation[png-w/o line collection]
PASSED lib/matplotlib/tests/test_axes.py::test_hist_stacked_stepfilled_alpha[png]
PASSED lib/matplotlib/tests/test_axes.py::test_hist_stacked_stepfilled_alpha[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_hist_stacked_stepfilled_alpha[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_hist_stacked_step[png]
PASSED lib/matplotlib/tests/test_axes.py::test_hist_stacked_step[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_hist_stacked_step[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_hist_stacked_density[png]
PASSED lib/matplotlib/tests/test_axes.py::test_hist_stacked_density[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_hist_stacked_density[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_hist_step_bottom[png]
PASSED lib/matplotlib/tests/test_axes.py::test_hist_stepfilled_geometry
PASSED lib/matplotlib/tests/test_axes.py::test_hist_step_geometry
PASSED lib/matplotlib/tests/test_axes.py::test_hist_stepfilled_bottom_geometry
PASSED lib/matplotlib/tests/test_axes.py::test_hist_step_bottom_geometry
PASSED lib/matplotlib/tests/test_axes.py::test_hist_stacked_stepfilled_geometry
PASSED lib/matplotlib/tests/test_axes.py::test_hist_stacked_step_geometry
PASSED lib/matplotlib/tests/test_axes.py::test_hist_stacked_stepfilled_bottom_geometry
PASSED lib/matplotlib/tests/test_axes.py::test_hist_stacked_step_bottom_geometry
PASSED lib/matplotlib/tests/test_axes.py::test_hist_stacked_bar[png]
PASSED lib/matplotlib/tests/test_axes.py::test_hist_stacked_bar[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_hist_stacked_bar[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_hist_barstacked_bottom_unchanged
PASSED lib/matplotlib/tests/test_axes.py::test_hist_emptydata
PASSED lib/matplotlib/tests/test_axes.py::test_hist_labels
PASSED lib/matplotlib/tests/test_axes.py::test_transparent_markers[png]
PASSED lib/matplotlib/tests/test_axes.py::test_transparent_markers[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_transparent_markers[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_rgba_markers[png]
PASSED lib/matplotlib/tests/test_axes.py::test_rgba_markers[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_rgba_markers[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_mollweide_grid[png]
PASSED lib/matplotlib/tests/test_axes.py::test_mollweide_grid[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_mollweide_grid[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_mollweide_forward_inverse_closure
PASSED lib/matplotlib/tests/test_axes.py::test_mollweide_inverse_forward_closure
PASSED lib/matplotlib/tests/test_axes.py::test_alpha[png]
PASSED lib/matplotlib/tests/test_axes.py::test_alpha[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_alpha[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_eventplot[png]
PASSED lib/matplotlib/tests/test_axes.py::test_eventplot[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_eventplot[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_eventplot_defaults[png]
PASSED lib/matplotlib/tests/test_axes.py::test_eventplot_colors[colors0]
PASSED lib/matplotlib/tests/test_axes.py::test_eventplot_colors[colors1]
PASSED lib/matplotlib/tests/test_axes.py::test_eventplot_colors[colors2]
PASSED lib/matplotlib/tests/test_axes.py::test_eventplot_problem_kwargs[png]
PASSED lib/matplotlib/tests/test_axes.py::test_empty_eventplot
PASSED lib/matplotlib/tests/test_axes.py::test_eventplot_orientation[None-data0]
PASSED lib/matplotlib/tests/test_axes.py::test_eventplot_orientation[None-data1]
PASSED lib/matplotlib/tests/test_axes.py::test_eventplot_orientation[None-data2]
PASSED lib/matplotlib/tests/test_axes.py::test_eventplot_orientation[vertical-data0]
PASSED lib/matplotlib/tests/test_axes.py::test_eventplot_orientation[vertical-data1]
PASSED lib/matplotlib/tests/test_axes.py::test_eventplot_orientation[vertical-data2]
PASSED lib/matplotlib/tests/test_axes.py::test_eventplot_orientation[horizontal-data0]
PASSED lib/matplotlib/tests/test_axes.py::test_eventplot_orientation[horizontal-data1]
PASSED lib/matplotlib/tests/test_axes.py::test_eventplot_orientation[horizontal-data2]
PASSED lib/matplotlib/tests/test_axes.py::test_eventplot_units_list[png]
PASSED lib/matplotlib/tests/test_axes.py::test_marker_styles[png]
PASSED lib/matplotlib/tests/test_axes.py::test_markers_fillstyle_rcparams[png]
PASSED lib/matplotlib/tests/test_axes.py::test_vertex_markers[png]
PASSED lib/matplotlib/tests/test_axes.py::test_eb_line_zorder[png]
PASSED lib/matplotlib/tests/test_axes.py::test_eb_line_zorder[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_eb_line_zorder[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_axline_loglog[png]
PASSED lib/matplotlib/tests/test_axes.py::test_axline_loglog[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_axline_loglog[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_axline[png]
PASSED lib/matplotlib/tests/test_axes.py::test_axline[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_axline[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_axline_transaxes[png]
PASSED lib/matplotlib/tests/test_axes.py::test_axline_transaxes[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_axline_transaxes[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_axline_transaxes_panzoom[png]
PASSED lib/matplotlib/tests/test_axes.py::test_axline_transaxes_panzoom[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_axline_transaxes_panzoom[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_axline_args
PASSED lib/matplotlib/tests/test_axes.py::test_vlines[png]
PASSED lib/matplotlib/tests/test_axes.py::test_vlines_default
PASSED lib/matplotlib/tests/test_axes.py::test_hlines[png]
PASSED lib/matplotlib/tests/test_axes.py::test_hlines_default
PASSED lib/matplotlib/tests/test_axes.py::test_lines_with_colors[png-data0]
PASSED lib/matplotlib/tests/test_axes.py::test_lines_with_colors[png-data1]
PASSED lib/matplotlib/tests/test_axes.py::test_step_linestyle[png]
PASSED lib/matplotlib/tests/test_axes.py::test_step_linestyle[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_step_linestyle[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_mixed_collection[png]
PASSED lib/matplotlib/tests/test_axes.py::test_mixed_collection[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_mixed_collection[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_subplot_key_hash
PASSED lib/matplotlib/tests/test_axes.py::test_specgram[png]
PASSED lib/matplotlib/tests/test_axes.py::test_specgram_magnitude[png]
PASSED lib/matplotlib/tests/test_axes.py::test_specgram_angle[png]
PASSED lib/matplotlib/tests/test_axes.py::test_specgram_fs_none
PASSED lib/matplotlib/tests/test_axes.py::test_specgram_origin_rcparam[png]
PASSED lib/matplotlib/tests/test_axes.py::test_specgram_origin_kwarg
PASSED lib/matplotlib/tests/test_axes.py::test_psd_csd[png]
PASSED lib/matplotlib/tests/test_axes.py::test_spectrum[png]
PASSED lib/matplotlib/tests/test_axes.py::test_twin_remove[png]
PASSED lib/matplotlib/tests/test_axes.py::test_twin_spines[png]
PASSED lib/matplotlib/tests/test_axes.py::test_twin_spines_on_top[png]
PASSED lib/matplotlib/tests/test_axes.py::test_rcparam_grid_minor[both-True-True]
PASSED lib/matplotlib/tests/test_axes.py::test_rcparam_grid_minor[major-True-False]
PASSED lib/matplotlib/tests/test_axes.py::test_rcparam_grid_minor[minor-False-True]
PASSED lib/matplotlib/tests/test_axes.py::test_grid
PASSED lib/matplotlib/tests/test_axes.py::test_reset_grid
PASSED lib/matplotlib/tests/test_axes.py::test_reset_ticks[png]
PASSED lib/matplotlib/tests/test_axes.py::test_vline_limit
PASSED lib/matplotlib/tests/test_axes.py::test_axline_minmax[axvline-axhline-args0]
PASSED lib/matplotlib/tests/test_axes.py::test_axline_minmax[axvspan-axhspan-args1]
PASSED lib/matplotlib/tests/test_axes.py::test_empty_shared_subplots
PASSED lib/matplotlib/tests/test_axes.py::test_shared_with_aspect_1
PASSED lib/matplotlib/tests/test_axes.py::test_shared_with_aspect_2
PASSED lib/matplotlib/tests/test_axes.py::test_shared_with_aspect_3
PASSED lib/matplotlib/tests/test_axes.py::test_shared_aspect_error
PASSED lib/matplotlib/tests/test_axes.py::test_axis_errors[TypeError-args0-kwargs0-axis\\(\\) takes 0 or 1 positional arguments but 2 were given]
PASSED lib/matplotlib/tests/test_axes.py::test_axis_errors[ValueError-args1-kwargs1-Unrecognized string 'foo' to axis; try 'on' or 'off']
PASSED lib/matplotlib/tests/test_axes.py::test_axis_errors[TypeError-args2-kwargs2-the first argument to axis*]
PASSED lib/matplotlib/tests/test_axes.py::test_axis_method_errors
PASSED lib/matplotlib/tests/test_axes.py::test_twin_with_aspect[x]
PASSED lib/matplotlib/tests/test_axes.py::test_twin_with_aspect[y]
PASSED lib/matplotlib/tests/test_axes.py::test_relim_visible_only
PASSED lib/matplotlib/tests/test_axes.py::test_text_labelsize
PASSED lib/matplotlib/tests/test_axes.py::test_pie_frame_grid[png]
PASSED lib/matplotlib/tests/test_axes.py::test_pie_get_negative_values
PASSED lib/matplotlib/tests/test_axes.py::test_set_get_ticklabels[png]
PASSED lib/matplotlib/tests/test_axes.py::test_set_ticks_with_labels[png]
PASSED lib/matplotlib/tests/test_axes.py::test_set_noniterable_ticklabels
PASSED lib/matplotlib/tests/test_axes.py::test_subsampled_ticklabels
PASSED lib/matplotlib/tests/test_axes.py::test_mismatched_ticklabels
PASSED lib/matplotlib/tests/test_axes.py::test_empty_ticks_fixed_loc
PASSED lib/matplotlib/tests/test_axes.py::test_retain_tick_visibility[png]
PASSED lib/matplotlib/tests/test_axes.py::test_tick_label_update
PASSED lib/matplotlib/tests/test_axes.py::test_o_marker_path_snap[png]
PASSED lib/matplotlib/tests/test_axes.py::test_margins
PASSED lib/matplotlib/tests/test_axes.py::test_set_margin_updates_limits
PASSED lib/matplotlib/tests/test_axes.py::test_margins_errors[ValueError-args0-kwargs0-margin must be greater than -0\\.5]
PASSED lib/matplotlib/tests/test_axes.py::test_margins_errors[ValueError-args1-kwargs1-margin must be greater than -0\\.5]
PASSED lib/matplotlib/tests/test_axes.py::test_margins_errors[ValueError-args2-kwargs2-margin must be greater than -0\\.5]
PASSED lib/matplotlib/tests/test_axes.py::test_margins_errors[ValueError-args3-kwargs3-margin must be greater than -0\\.5]
PASSED lib/matplotlib/tests/test_axes.py::test_margins_errors[TypeError-args4-kwargs4-Cannot pass both positional and keyword arguments for x and/or y]
PASSED lib/matplotlib/tests/test_axes.py::test_margins_errors[TypeError-args5-kwargs5-Cannot pass both positional and keyword arguments for x and/or y]
PASSED lib/matplotlib/tests/test_axes.py::test_margins_errors[TypeError-args6-kwargs6-Must pass a single positional argument]
PASSED lib/matplotlib/tests/test_axes.py::test_length_one_hist
PASSED lib/matplotlib/tests/test_axes.py::test_set_xy_bound
PASSED lib/matplotlib/tests/test_axes.py::test_pathological_hexbin
PASSED lib/matplotlib/tests/test_axes.py::test_color_None
PASSED lib/matplotlib/tests/test_axes.py::test_color_alias
PASSED lib/matplotlib/tests/test_axes.py::test_numerical_hist_label
PASSED lib/matplotlib/tests/test_axes.py::test_unicode_hist_label
PASSED lib/matplotlib/tests/test_axes.py::test_move_offsetlabel
PASSED lib/matplotlib/tests/test_axes.py::test_rc_spines[png]
PASSED lib/matplotlib/tests/test_axes.py::test_rc_grid[png]
PASSED lib/matplotlib/tests/test_axes.py::test_rc_tick
PASSED lib/matplotlib/tests/test_axes.py::test_rc_major_minor_tick
PASSED lib/matplotlib/tests/test_axes.py::test_square_plot
PASSED lib/matplotlib/tests/test_axes.py::test_bad_plot_args
PASSED lib/matplotlib/tests/test_axes.py::test_pcolorfast[data0-xy0-AxesImage]
PASSED lib/matplotlib/tests/test_axes.py::test_pcolorfast[data0-xy1-AxesImage]
PASSED lib/matplotlib/tests/test_axes.py::test_pcolorfast[data0-xy2-AxesImage]
PASSED lib/matplotlib/tests/test_axes.py::test_pcolorfast[data0-xy3-PcolorImage]
PASSED lib/matplotlib/tests/test_axes.py::test_pcolorfast[data0-xy4-QuadMesh]
PASSED lib/matplotlib/tests/test_axes.py::test_pcolorfast[data1-xy0-AxesImage]
PASSED lib/matplotlib/tests/test_axes.py::test_pcolorfast[data1-xy1-AxesImage]
PASSED lib/matplotlib/tests/test_axes.py::test_pcolorfast[data1-xy2-AxesImage]
PASSED lib/matplotlib/tests/test_axes.py::test_pcolorfast[data1-xy3-PcolorImage]
PASSED lib/matplotlib/tests/test_axes.py::test_pcolorfast[data1-xy4-QuadMesh]
PASSED lib/matplotlib/tests/test_axes.py::test_shared_scale
PASSED lib/matplotlib/tests/test_axes.py::test_shared_bool
PASSED lib/matplotlib/tests/test_axes.py::test_violin_point_mass
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs0]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs1]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs2]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs3]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs4]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs5]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs6]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs7]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs8]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs9]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs10]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs11]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs12]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs13]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs14]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs15]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs16]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs17]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs18]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs19]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs20]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs21]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs22]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs23]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs24]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs25]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs26]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs27]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs28]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs29]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs30]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs31]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs32]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs33]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs34]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs35]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs36]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs37]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs38]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs39]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs40]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs41]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs42]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs43]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs44]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs45]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs46]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs47]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs48]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs49]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs50]
PASSED lib/matplotlib/tests/test_axes.py::test_errorbar_inputs_shotgun[kwargs51]
PASSED lib/matplotlib/tests/test_axes.py::test_dash_offset[png]
PASSED lib/matplotlib/tests/test_axes.py::test_dash_offset[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_dash_offset[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_title_pad
PASSED lib/matplotlib/tests/test_axes.py::test_title_location_roundtrip
PASSED lib/matplotlib/tests/test_axes.py::test_title_location_shared[True]
PASSED lib/matplotlib/tests/test_axes.py::test_title_location_shared[False]
PASSED lib/matplotlib/tests/test_axes.py::test_loglog[png]
PASSED lib/matplotlib/tests/test_axes.py::test_loglog_nonpos[png]
PASSED lib/matplotlib/tests/test_axes.py::test_axes_margins
PASSED lib/matplotlib/tests/test_axes.py::test_remove_shared_axes[gca-x]
PASSED lib/matplotlib/tests/test_axes.py::test_remove_shared_axes[gca-y]
PASSED lib/matplotlib/tests/test_axes.py::test_remove_shared_axes[subplots-x]
PASSED lib/matplotlib/tests/test_axes.py::test_remove_shared_axes[subplots-y]
PASSED lib/matplotlib/tests/test_axes.py::test_remove_shared_axes[subplots_shared-x]
PASSED lib/matplotlib/tests/test_axes.py::test_remove_shared_axes[subplots_shared-y]
PASSED lib/matplotlib/tests/test_axes.py::test_remove_shared_axes[add_axes-x]
PASSED lib/matplotlib/tests/test_axes.py::test_remove_shared_axes[add_axes-y]
PASSED lib/matplotlib/tests/test_axes.py::test_remove_shared_axes_relim
PASSED lib/matplotlib/tests/test_axes.py::test_shared_axes_autoscale
PASSED lib/matplotlib/tests/test_axes.py::test_adjust_numtick_aspect
PASSED lib/matplotlib/tests/test_axes.py::test_auto_numticks
PASSED lib/matplotlib/tests/test_axes.py::test_auto_numticks_log
PASSED lib/matplotlib/tests/test_axes.py::test_broken_barh_empty
PASSED lib/matplotlib/tests/test_axes.py::test_broken_barh_timedelta
PASSED lib/matplotlib/tests/test_axes.py::test_pandas_pcolormesh
PASSED lib/matplotlib/tests/test_axes.py::test_pandas_indexing_dates
PASSED lib/matplotlib/tests/test_axes.py::test_pandas_errorbar_indexing
PASSED lib/matplotlib/tests/test_axes.py::test_pandas_index_shape
PASSED lib/matplotlib/tests/test_axes.py::test_pandas_indexing_hist
PASSED lib/matplotlib/tests/test_axes.py::test_pandas_bar_align_center
PASSED lib/matplotlib/tests/test_axes.py::test_tick_apply_tickdir_deprecation
PASSED lib/matplotlib/tests/test_axes.py::test_axis_set_tick_params_labelsize_labelcolor
PASSED lib/matplotlib/tests/test_axes.py::test_axes_tick_params_gridlines
PASSED lib/matplotlib/tests/test_axes.py::test_axes_tick_params_ylabelside
PASSED lib/matplotlib/tests/test_axes.py::test_axes_tick_params_xlabelside
PASSED lib/matplotlib/tests/test_axes.py::test_none_kwargs
PASSED lib/matplotlib/tests/test_axes.py::test_bar_uint8
PASSED lib/matplotlib/tests/test_axes.py::test_date_timezone_x[png]
PASSED lib/matplotlib/tests/test_axes.py::test_date_timezone_y[png]
PASSED lib/matplotlib/tests/test_axes.py::test_date_timezone_x_and_y[png]
PASSED lib/matplotlib/tests/test_axes.py::test_axisbelow[png]
PASSED lib/matplotlib/tests/test_axes.py::test_titletwiny
PASSED lib/matplotlib/tests/test_axes.py::test_titlesetpos
PASSED lib/matplotlib/tests/test_axes.py::test_title_xticks_top
PASSED lib/matplotlib/tests/test_axes.py::test_title_xticks_top_both
PASSED lib/matplotlib/tests/test_axes.py::test_title_above_offset[left title moved]
PASSED lib/matplotlib/tests/test_axes.py::test_title_above_offset[center title kept]
PASSED lib/matplotlib/tests/test_axes.py::test_title_above_offset[both titles aligned]
PASSED lib/matplotlib/tests/test_axes.py::test_title_no_move_off_page
PASSED lib/matplotlib/tests/test_axes.py::test_offset_label_color
PASSED lib/matplotlib/tests/test_axes.py::test_offset_text_visible
PASSED lib/matplotlib/tests/test_axes.py::test_large_offset
PASSED lib/matplotlib/tests/test_axes.py::test_barb_units
PASSED lib/matplotlib/tests/test_axes.py::test_quiver_units
PASSED lib/matplotlib/tests/test_axes.py::test_bar_color_cycle
PASSED lib/matplotlib/tests/test_axes.py::test_tick_param_label_rotation
PASSED lib/matplotlib/tests/test_axes.py::test_fillbetween_cycle
PASSED lib/matplotlib/tests/test_axes.py::test_log_margins
PASSED lib/matplotlib/tests/test_axes.py::test_color_length_mismatch
PASSED lib/matplotlib/tests/test_axes.py::test_eventplot_legend
PASSED lib/matplotlib/tests/test_axes.py::test_bar_broadcast_args
PASSED lib/matplotlib/tests/test_axes.py::test_invalid_axis_limits
PASSED lib/matplotlib/tests/test_axes.py::test_minorticks_on[symlog-symlog]
PASSED lib/matplotlib/tests/test_axes.py::test_minorticks_on[symlog-log]
PASSED lib/matplotlib/tests/test_axes.py::test_minorticks_on[log-symlog]
PASSED lib/matplotlib/tests/test_axes.py::test_minorticks_on[log-log]
PASSED lib/matplotlib/tests/test_axes.py::test_twinx_knows_limits
PASSED lib/matplotlib/tests/test_axes.py::test_zero_linewidth
PASSED lib/matplotlib/tests/test_axes.py::test_empty_errorbar_legend
PASSED lib/matplotlib/tests/test_axes.py::test_plot_decimal[png]
PASSED lib/matplotlib/tests/test_axes.py::test_markerfacecolor_none_alpha[png]
PASSED lib/matplotlib/tests/test_axes.py::test_tick_padding_tightbbox
PASSED lib/matplotlib/tests/test_axes.py::test_inset
PASSED lib/matplotlib/tests/test_axes.py::test_zoom_inset
PASSED lib/matplotlib/tests/test_axes.py::test_inset_polar[png]
PASSED lib/matplotlib/tests/test_axes.py::test_inset_projection
PASSED lib/matplotlib/tests/test_axes.py::test_inset_subclass
PASSED lib/matplotlib/tests/test_axes.py::test_indicate_inset_inverted[False-False]
PASSED lib/matplotlib/tests/test_axes.py::test_indicate_inset_inverted[False-True]
PASSED lib/matplotlib/tests/test_axes.py::test_indicate_inset_inverted[True-False]
PASSED lib/matplotlib/tests/test_axes.py::test_indicate_inset_inverted[True-True]
PASSED lib/matplotlib/tests/test_axes.py::test_set_position
PASSED lib/matplotlib/tests/test_axes.py::test_spines_properbbox_after_zoom
PASSED lib/matplotlib/tests/test_axes.py::test_gettightbbox_ignore_nan
PASSED lib/matplotlib/tests/test_axes.py::test_scatter_series_non_zero_index
PASSED lib/matplotlib/tests/test_axes.py::test_annotate_across_transforms[png]
PASSED lib/matplotlib/tests/test_axes.py::test_secondary_xy[png]
PASSED lib/matplotlib/tests/test_axes.py::test_secondary_fail
PASSED lib/matplotlib/tests/test_axes.py::test_secondary_resize
PASSED lib/matplotlib/tests/test_axes.py::test_secondary_minorloc
PASSED lib/matplotlib/tests/test_axes.py::test_secondary_formatter
PASSED lib/matplotlib/tests/test_axes.py::test_secondary_repr
PASSED lib/matplotlib/tests/test_axes.py::test_normal_axes
PASSED lib/matplotlib/tests/test_axes.py::test_nodecorator
PASSED lib/matplotlib/tests/test_axes.py::test_displaced_spine
PASSED lib/matplotlib/tests/test_axes.py::test_tickdirs
PASSED lib/matplotlib/tests/test_axes.py::test_minor_accountedfor
PASSED lib/matplotlib/tests/test_axes.py::test_axis_bool_arguments[png]
PASSED lib/matplotlib/tests/test_axes.py::test_axis_extent_arg
PASSED lib/matplotlib/tests/test_axes.py::test_axis_extent_arg2
PASSED lib/matplotlib/tests/test_axes.py::test_hist_auto_bins
PASSED lib/matplotlib/tests/test_axes.py::test_hist_nan_data
PASSED lib/matplotlib/tests/test_axes.py::test_hist_range_and_density
PASSED lib/matplotlib/tests/test_axes.py::test_bar_errbar_zorder
PASSED lib/matplotlib/tests/test_axes.py::test_set_ticks_inverted
PASSED lib/matplotlib/tests/test_axes.py::test_aspect_nonlinear_adjustable_box
PASSED lib/matplotlib/tests/test_axes.py::test_aspect_nonlinear_adjustable_datalim
PASSED lib/matplotlib/tests/test_axes.py::test_box_aspect
PASSED lib/matplotlib/tests/test_axes.py::test_box_aspect_custom_position
PASSED lib/matplotlib/tests/test_axes.py::test_bbox_aspect_axes_init
PASSED lib/matplotlib/tests/test_axes.py::test_redraw_in_frame
PASSED lib/matplotlib/tests/test_axes.py::test_invisible_axes_events
PASSED lib/matplotlib/tests/test_axes.py::test_xtickcolor_is_not_markercolor
PASSED lib/matplotlib/tests/test_axes.py::test_ytickcolor_is_not_markercolor
PASSED lib/matplotlib/tests/test_axes.py::test_unautoscale[True-x]
PASSED lib/matplotlib/tests/test_axes.py::test_unautoscale[True-y]
PASSED lib/matplotlib/tests/test_axes.py::test_unautoscale[False-x]
PASSED lib/matplotlib/tests/test_axes.py::test_unautoscale[False-y]
PASSED lib/matplotlib/tests/test_axes.py::test_unautoscale[None-x]
PASSED lib/matplotlib/tests/test_axes.py::test_unautoscale[None-y]
PASSED lib/matplotlib/tests/test_axes.py::test_polar_interpolation_steps_variable_r[png]
PASSED lib/matplotlib/tests/test_axes.py::test_autoscale_tiny_sticky
PASSED lib/matplotlib/tests/test_axes.py::test_xtickcolor_is_not_xticklabelcolor
PASSED lib/matplotlib/tests/test_axes.py::test_ytickcolor_is_not_yticklabelcolor
PASSED lib/matplotlib/tests/test_axes.py::test_relative_ticklabel_sizes[xx-small]
PASSED lib/matplotlib/tests/test_axes.py::test_relative_ticklabel_sizes[x-small]
PASSED lib/matplotlib/tests/test_axes.py::test_relative_ticklabel_sizes[small]
PASSED lib/matplotlib/tests/test_axes.py::test_relative_ticklabel_sizes[medium]
PASSED lib/matplotlib/tests/test_axes.py::test_relative_ticklabel_sizes[large]
PASSED lib/matplotlib/tests/test_axes.py::test_relative_ticklabel_sizes[x-large]
PASSED lib/matplotlib/tests/test_axes.py::test_relative_ticklabel_sizes[xx-large]
PASSED lib/matplotlib/tests/test_axes.py::test_relative_ticklabel_sizes[larger]
PASSED lib/matplotlib/tests/test_axes.py::test_relative_ticklabel_sizes[smaller]
PASSED lib/matplotlib/tests/test_axes.py::test_relative_ticklabel_sizes[8]
PASSED lib/matplotlib/tests/test_axes.py::test_relative_ticklabel_sizes[10]
PASSED lib/matplotlib/tests/test_axes.py::test_relative_ticklabel_sizes[12]
PASSED lib/matplotlib/tests/test_axes.py::test_multiplot_autoscale
PASSED lib/matplotlib/tests/test_axes.py::test_sharing_does_not_link_positions
PASSED lib/matplotlib/tests/test_axes.py::test_2dcolor_plot[pdf]
PASSED lib/matplotlib/tests/test_axes.py::test_shared_axes_clear[png]
PASSED lib/matplotlib/tests/test_axes.py::test_shared_axes_retick
PASSED lib/matplotlib/tests/test_axes.py::test_ylabel_ha_with_position[left]
PASSED lib/matplotlib/tests/test_axes.py::test_ylabel_ha_with_position[center]
PASSED lib/matplotlib/tests/test_axes.py::test_ylabel_ha_with_position[right]
PASSED lib/matplotlib/tests/test_axes.py::test_bar_label_location_vertical
PASSED lib/matplotlib/tests/test_axes.py::test_bar_label_location_vertical_yinverted
PASSED lib/matplotlib/tests/test_axes.py::test_bar_label_location_horizontal
PASSED lib/matplotlib/tests/test_axes.py::test_bar_label_location_horizontal_yinverted
PASSED lib/matplotlib/tests/test_axes.py::test_bar_label_location_horizontal_xinverted
PASSED lib/matplotlib/tests/test_axes.py::test_bar_label_location_horizontal_xyinverted
PASSED lib/matplotlib/tests/test_axes.py::test_bar_label_location_center
PASSED lib/matplotlib/tests/test_axes.py::test_centered_bar_label_nonlinear[svg]
PASSED lib/matplotlib/tests/test_axes.py::test_bar_label_location_errorbars
PASSED lib/matplotlib/tests/test_axes.py::test_bar_label_fmt[%.2f]
PASSED lib/matplotlib/tests/test_axes.py::test_bar_label_fmt[{:.2f}]
PASSED lib/matplotlib/tests/test_axes.py::test_bar_label_fmt[format]
PASSED lib/matplotlib/tests/test_axes.py::test_bar_label_fmt_error
PASSED lib/matplotlib/tests/test_axes.py::test_bar_label_labels
PASSED lib/matplotlib/tests/test_axes.py::test_bar_label_nan_ydata
PASSED lib/matplotlib/tests/test_axes.py::test_bar_label_nan_ydata_inverted
PASSED lib/matplotlib/tests/test_axes.py::test_nan_barlabels
PASSED lib/matplotlib/tests/test_axes.py::test_patch_bounds
PASSED lib/matplotlib/tests/test_axes.py::test_warn_ignored_scatter_kwargs
PASSED lib/matplotlib/tests/test_axes.py::test_artist_sublists
PASSED lib/matplotlib/tests/test_axes.py::test_empty_line_plots
PASSED lib/matplotlib/tests/test_axes.py::test_plot_format_errors[None-f-'f' is not a valid format string \\(unrecognized character 'f'\\)]
PASSED lib/matplotlib/tests/test_axes.py::test_plot_format_errors[None-o+-'o\\+' is not a valid format string \\(two marker symbols\\)]
PASSED lib/matplotlib/tests/test_axes.py::test_plot_format_errors[None-:--':-' is not a valid format string \\(two linestyle symbols\\)]
PASSED lib/matplotlib/tests/test_axes.py::test_plot_format_errors[None-rk-'rk' is not a valid format string \\(two color symbols\\)]
PASSED lib/matplotlib/tests/test_axes.py::test_plot_format_errors[None-:o-r-':o-r' is not a valid format string \\(two linestyle symbols\\)]
PASSED lib/matplotlib/tests/test_axes.py::test_plot_format_errors[data1-f-'f' is not a valid format string \\(unrecognized character 'f'\\)]
PASSED lib/matplotlib/tests/test_axes.py::test_plot_format_errors[data1-o+-'o\\+' is not a valid format string \\(two marker symbols\\)]
PASSED lib/matplotlib/tests/test_axes.py::test_plot_format_errors[data1-:--':-' is not a valid format string \\(two linestyle symbols\\)]
PASSED lib/matplotlib/tests/test_axes.py::test_plot_format_errors[data1-rk-'rk' is not a valid format string \\(two color symbols\\)]
PASSED lib/matplotlib/tests/test_axes.py::test_plot_format_errors[data1-:o-r-':o-r' is not a valid format string \\(two linestyle symbols\\)]
PASSED lib/matplotlib/tests/test_axes.py::test_plot_format
PASSED lib/matplotlib/tests/test_axes.py::test_automatic_legend
PASSED lib/matplotlib/tests/test_axes.py::test_plot_errors
PASSED lib/matplotlib/tests/test_axes.py::test_clim
PASSED lib/matplotlib/tests/test_axes.py::test_bezier_autoscale
PASSED lib/matplotlib/tests/test_axes.py::test_get_xticklabel
PASSED lib/matplotlib/tests/test_axes.py::test_bar_leading_nan
FAILED lib/matplotlib/tests/test_axes.py::test_label_loc_vertical[png] - Valu...
FAILED lib/matplotlib/tests/test_axes.py::test_label_loc_vertical[pdf] - Valu...
FAILED lib/matplotlib/tests/test_axes.py::test_label_loc_vertical[svg] - Valu...
FAILED lib/matplotlib/tests/test_axes.py::test_label_loc_horizontal[png] - Va...
FAILED lib/matplotlib/tests/test_axes.py::test_label_loc_horizontal[pdf] - Va...
FAILED lib/matplotlib/tests/test_axes.py::test_label_loc_horizontal[svg] - Va...
FAILED lib/matplotlib/tests/test_axes.py::test_label_loc_rc[png] - ValueError...
FAILED lib/matplotlib/tests/test_axes.py::test_label_loc_rc[pdf] - ValueError...
FAILED lib/matplotlib/tests/test_axes.py::test_label_loc_rc[svg] - ValueError...
FAILED lib/matplotlib/tests/test_axes.py::test_hexbin_empty[png] - ValueError...
FAILED lib/matplotlib/tests/test_axes.py::test_hexbin_log[png] - ValueError: ...
FAILED lib/matplotlib/tests/test_axes.py::test_limits_empty_data[png-scatter]
FAILED lib/matplotlib/tests/test_axes.py::test_limits_empty_data[png-fill_between]
FAILED lib/matplotlib/tests/test_axes.py::test_pcolormesh_small[eps] - matplo...
FAILED lib/matplotlib/tests/test_axes.py::test_bar_ticklabel_fail - ValueErro...
FAILED lib/matplotlib/tests/test_axes.py::test_hist_bar_empty[png] - ValueErr...
FAILED lib/matplotlib/tests/test_axes.py::test_hist_step_empty[png] - ValueEr...
FAILED lib/matplotlib/tests/test_axes.py::test_hist_with_empty_input[data0-1]
FAILED lib/matplotlib/tests/test_axes.py::test_stairs_empty - ValueError: No ...
FAILED lib/matplotlib/tests/test_axes.py::test_contour_colorbar[png] - ValueE...
FAILED lib/matplotlib/tests/test_axes.py::test_contour_colorbar[pdf] - ValueE...
FAILED lib/matplotlib/tests/test_axes.py::test_contour_colorbar[svg] - ValueE...
FAILED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_color_warning[kwargs0]
FAILED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_color_warning[kwargs1]
FAILED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_color_warning[kwargs2]
FAILED lib/matplotlib/tests/test_axes.py::TestScatter::test_scatter_color_warning[kwargs3]
FAILED lib/matplotlib/tests/test_axes.py::test_psd_csd_edge_cases - ValueErro...
FAILED lib/matplotlib/tests/test_axes.py::test_axis_errors[TypeError-args3-kwargs3-axis\\(\\) got an unexpected keyword argument 'foo']
FAILED lib/matplotlib/tests/test_axes.py::test_pie_default[png] - ValueError:...
FAILED lib/matplotlib/tests/test_axes.py::test_pie_linewidth_0[png] - ValueEr...
FAILED lib/matplotlib/tests/test_axes.py::test_pie_center_radius[png] - Value...
FAILED lib/matplotlib/tests/test_axes.py::test_pie_linewidth_2[png] - ValueEr...
FAILED lib/matplotlib/tests/test_axes.py::test_pie_ccw_true[png] - ValueError...
FAILED lib/matplotlib/tests/test_axes.py::test_pie_rotatelabels_true[png] - V...
FAILED lib/matplotlib/tests/test_axes.py::test_pie_nolabel_but_legend[png] - ...
FAILED lib/matplotlib/tests/test_axes.py::test_pie_textprops - ValueError: No...
FAILED lib/matplotlib/tests/test_axes.py::test_normalize_kwarg_pie - ValueErr...
FAILED lib/matplotlib/tests/test_axes.py::test_scatter_empty_data - ValueErro...
FAILED lib/matplotlib/tests/test_axes.py::test_bar_all_nan[png] - ValueError:...
================== 39 failed, 793 passed in 128.40s (0:02:08) ==================

Error processing line 1 of /root/miniforge3/envs/matplotlib__matplotlib__3.6/lib/python3.11/site-packages/matplotlib-nspkg.pth:

  Traceback (most recent call last):
    File "<frozen site>", line 195, in addpackage
    File "<string>", line 1, in <module>
    File "<frozen importlib._bootstrap>", line 570, in module_from_spec
  AttributeError: 'NoneType' object has no attribute 'loader'

Remainder of file ignored

ERROR conda.cli.main_run:execute(125): `conda run pytest -rA lib/matplotlib/tests/test_axes.py` failed. (See above for error)
