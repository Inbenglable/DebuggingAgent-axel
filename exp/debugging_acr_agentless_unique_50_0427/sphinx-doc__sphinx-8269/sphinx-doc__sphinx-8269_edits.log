### sphinx/builders/linkcheck.py
<<<<<<< SEARCH
def check_anchor(response: requests.Response, anchor: str) -> bool:
    """Reads HTML data from a response object `response` searching for `anchor`.
    Returns True if anchor was found, False otherwise.
=======
def check_anchor(response: requests.Response, anchor: str) -> Tuple[bool, str]:
    """Reads HTML data from a response object `response` searching for `anchor`.
    Returns a tuple (True, '') if anchor was found, (False, error message) otherwise.
    """
    if response.status_code != 200:
        return False, f"{response.status_code} {response.reason}"
>>>>>>> REPLACE
### sphinx/builders/linkcheck.py
<<<<<<< SEARCH
    parser = AnchorCheckParser(anchor)
    # Read file in chunks. If we find a matching anchor, we break
    # the loop early in hopes not to have to download the whole thing.
    for chunk in response.iter_content(chunk_size=4096, decode_unicode=True):
=======
    parser = AnchorCheckParser(anchor)
    error_message = ""
    # Read file in chunks. If we find a matching anchor, we break
    # the loop early in hopes not to have to download the whole thing.
    for chunk in response.iter_content(chunk_size=4096, decode_unicode=True):
        if error_message:
            break
>>>>>>> REPLACE
### sphinx/builders/linkcheck.py
<<<<<<< SEARCH
    return parser.found
=======
    return parser.found, error_message
>>>>>>> REPLACE
### sphinx/builders/linkcheck.py
<<<<<<< SEARCH
def process_result(self, result: bool, uri: str, info: Any) -> None:
    if result:
        self.good.append(uri)
    else:
        self.broken.append(uri)
=======
def process_result(self, result: bool, uri: str, error_message: str) -> None:
    if error_message:
        self.broken.append(f"{uri} - {error_message}")
    elif result:
        self.good.append(uri)
    else:
        self.broken.append(f"{uri} - Anchor not found")
>>>>>>> REPLACE