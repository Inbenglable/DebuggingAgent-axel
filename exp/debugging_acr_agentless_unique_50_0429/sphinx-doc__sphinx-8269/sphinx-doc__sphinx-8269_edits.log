### sphinx/builders/linkcheck.py
<<<<<<< SEARCH
def check_anchor(response: requests.requests.Response, anchor: str) -> bool:
    """Reads HTML data from a response object `response` searching for `anchor`.
    Returns True if anchor was found, False otherwise.
    """
    parser = AnchorCheckParser(anchor)
    # Read file in chunks. If we find a matching anchor, we break
    # the loop early in hopes not to have to download the whole thing.
    for chunk in response.iter_content(chunk_size=4096, decode_unicode=True):
        if isinstance(chunk, bytes):    # requests failed to decode
            chunk = chunk.decode()      # manually try to decode it

        parser.feed(chunk)
        if parser.found:
            break
    parser.close()
    return parser.found
=======

def process_linkcheck_result(uri: str, response: requests.requests.Response, anchor: str) -> str:
    """Processes the result from a linkcheck, returning the result string."""
    if response.status_code >= 400:
        return f"{response.status_code} Client Error: {response.reason} for url: {uri}"
    
    if response.headers.get('content-type').startswith('text/html'):
        if not check_anchor(response, anchor):
            return f"Anchor '{anchor}' not found"
    return "Working"
    
def check_anchor(response: requests.requests.Response, anchor: str) -> bool:
    """Reads HTML data from a response object `response` searching for `anchor`.
    Returns True if anchor was found, False otherwise.
    """
    parser = AnchorCheckParser(anchor)
    # Read file in chunks. If we find a matching anchor, we break
    # the loop early in hopes not to have to download the whole thing.
    for chunk in response.iter_content(chunk_size=4096, decode_unicode=True):
        if isinstance(chunk, bytes):    # requests failed to decode
            chunk = chunk.decode()      # manually try to decode it

        parser.feed(chunk)
        if parser.found:
            break
    parser.close()
    return parser.found
>>>>>>> REPLACE
